<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fringes.fringes &mdash; Fringes 0.2.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Fringes
          </a>
              <div class="version">
                0.2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">fringes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Fringes</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../fringes.html">fringes</a></li>
      <li class="breadcrumb-item active">fringes.fringes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for fringes.fringes</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span> <span class="k">as</span> <span class="nn">lg</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">toml</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">asdf</span>
<span class="kn">from</span> <span class="nn">si_prefix</span> <span class="kn">import</span> <span class="n">si_format</span> <span class="k">as</span> <span class="n">si</span>


<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">vshape</span><span class="p">,</span> <span class="n">bilateral</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">remap</span><span class="p">,</span> <span class="n">circular_distance</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">grid</span>

<span class="c1"># from .decoder import decode  # todo: fast_decode i.e. fast_unwrap</span>
<span class="kn">from</span> <span class="nn">.decoder4</span> <span class="kn">import</span> <span class="n">decode</span>  <span class="c1"># todo: fast_decode i.e. fast_unwrap</span>


<div class="viewcode-block" id="Fringes"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes">[docs]</a><span class="k">class</span> <span class="nc">Fringes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Easy to use class for generating and analyzing fringe patterns with phase shifting algorithms.&quot;&quot;&quot;</span>

    <span class="c1"># value limits</span>
    <span class="n">_Hmax</span> <span class="o">=</span> <span class="mi">101</span>  <span class="c1"># this is arbitrary</span>
    <span class="n">_Dmax</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># max 2 dimensions</span>
    <span class="n">_Kmax</span> <span class="o">=</span> <span class="mi">101</span>  <span class="c1"># this is arbitrary, but must be &lt; 128 when deploying spatial or frequency multiplexing @ uint8</span>
    <span class="n">_Nmax</span> <span class="o">=</span> <span class="mi">1001</span>  <span class="c1"># this is arbitrary; more is better but the improvement scales with sqrt(N); @FDM: &gt; 2 * fmax + 1</span>
    <span class="n">_Mmax</span> <span class="o">=</span> <span class="mi">101</span>  <span class="c1"># this is arbitrary; more is better but the improvement scales with sqrt(M)</span>
    <span class="c1"># _Pmax: int = 35651584  # ~8K i.e. max luma picture size of h264, h265, h266 video codecs as of 2022; todo: update</span>
    <span class="n">_Pmax</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">30</span>  <span class="c1"># 2^30 = 1,073,741,824 i.e. default size   limit of imread() in OpenCV</span>
    <span class="n">_Xmax</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span>  <span class="c1"># 2^20 = 1,048,576     i.e. default width  limit of imread() in OpenCV</span>
    <span class="n">_Ymax</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span>  <span class="c1"># 2^20 = 1,048,576     i.e. default height limit of imread() in OpenCV</span>
    <span class="n">_Lmax</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span>  <span class="c1"># 2^20 = 1,048,576     i.e. default height limit of imread() in OpenCV</span>
    <span class="n">_Tmax</span> <span class="o">=</span> <span class="n">_Hmax</span> <span class="o">*</span> <span class="n">_Dmax</span> <span class="o">*</span> <span class="n">_Kmax</span> <span class="o">*</span> <span class="n">_Nmax</span>
    <span class="n">_alphamax</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">_gammamax</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># most screens have a gamma of ~2.2</span>
    <span class="c1"># _lminmin = 2  # l == 2 only if offset != pi / 2 + 2pi*k, best if offset == pi + 2pi*k with k is positive integer</span>
    <span class="c1">#            also l &lt;= 2 yields errors in SPU: phase jumps = 2PI / lmin &gt;= np.pi</span>
    <span class="n">_lminmin</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># l &gt;= 3 yields sufficient modulation theoretically</span>
    <span class="c1"># _lminmin = 8  # l &gt;= 8 yields sufficient modulation practically [Liu2014]</span>

    <span class="c1"># allowed values; take care to only use immutable types!</span>
    <span class="n">_grids</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;Cartesian&quot;</span><span class="p">,</span> <span class="s2">&quot;polar&quot;</span><span class="p">,</span> <span class="s2">&quot;log-polar&quot;</span><span class="p">)</span>
    <span class="n">_modes</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;fast&quot;</span><span class="p">,</span> <span class="s2">&quot;precise&quot;</span><span class="p">)</span>
    <span class="n">_dtypes</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
        <span class="s2">&quot;uint8&quot;</span><span class="p">,</span>
        <span class="s2">&quot;uint16&quot;</span><span class="p">,</span>
        <span class="c1"># &#39;uint32&#39;,  # integer overflow in pyqtgraph -&gt; replace line 528 of ImageItem.py with:</span>
        <span class="c1"># &#39;uint64&#39;,  # bins = self._xp.arange(mn, mx + 1.01 * step, step, dtype=&quot;uint64&quot;)</span>
        <span class="c1"># &quot;float16&quot;,  # numba doesn&#39;t handle float16, also most algorithms convert float16 to float32 anyway</span>
        <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="s2">&quot;float64&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_loader</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;.json&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">,</span>
        <span class="s2">&quot;.yaml&quot;</span><span class="p">:</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">,</span>
        <span class="s2">&quot;.toml&quot;</span><span class="p">:</span> <span class="n">toml</span><span class="o">.</span><span class="n">load</span><span class="p">,</span>
        <span class="s2">&quot;.asdf&quot;</span><span class="p">:</span> <span class="n">asdf</span><span class="o">.</span><span class="n">open</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># default values are defined here; take care to only use immutable types!</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1200</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">,</span>
        <span class="n">H</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># inferred from h</span>
        <span class="n">M</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># inferred from h</span>
        <span class="n">D</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>  <span class="c1"># T is inferred</span>
        <span class="n">N</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="nb">int</span><span class="p">),</span>
        <span class="n">l</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="mi">1920</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">89</span><span class="p">],</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">89</span><span class="p">]],</span> <span class="nb">float</span><span class="p">),</span>  <span class="c1"># inferred from v</span>
        <span class="n">v</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">89</span><span class="p">],</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">89</span><span class="p">]],</span> <span class="nb">float</span><span class="p">),</span>
        <span class="n">f</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="nb">float</span><span class="p">),</span>
        <span class="n">h</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">]],</span> <span class="nb">int</span><span class="p">),</span>
        <span class="n">o</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">A</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># i.e. Imax / 2 @ uint8; inferred from Imax and beta</span>
        <span class="n">B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># i.e. Imax / 2 @ uint8; inferred from Imax and beta and V</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># V is inferred from A and B</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;uint8&quot;</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span>
        <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">SDM</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">WDM</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">FDM</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">static</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">8.0</span><span class="p">,</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;fast&quot;</span><span class="p">,</span>
        <span class="n">umin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">Bv</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">magnification</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">PSF</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">dark</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">y0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># given values which are in defaults but are not identical to them</span>
        <span class="n">given</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="c1"># logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>  <span class="c1"># todo: give each logger its own instance name, via id() ?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">hasHandlers</span><span class="p">():</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> </span><span class="si">%(levelname)-8s</span><span class="s2"> </span><span class="si">%(name)7s</span><span class="s2">.</span><span class="si">%(funcName)-11s</span><span class="s2">: </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
            <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

        <span class="c1"># set default values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used for caching</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;HMTlAB&quot;</span><span class="p">:</span>  <span class="c1"># these properties are inferred from others</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>  <span class="c1"># define private variables from where the properties get their value from</span>

        <span class="c1"># set given values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">given</span>

        <span class="c1"># _ = self.UMR  # property &#39;UMR&#39; logs warning if necessary</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frames</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)[</span><span class="n">frames</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">frames</span><span class="o">=</span><span class="n">frames</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">frames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">I</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;params&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">params</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;Fringes&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="Fringes.load"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load parameters from a config file to the &#39;Fringes&#39; instance.</span>

<span class="sd">        .. warning:: The parameters are only loaded if the config file provides the section `fringes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str, optional</span>
<span class="sd">            File name of the file to load.</span>
<span class="sd">            Supported file formats are: *.json, *.yaml, *.toml, *.asdf.</span>
<span class="sd">            If `&#39;fname&#39;` is not provided, the file `.fringes.yaml` within the user home directory is loaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            The loaded parameters as a dictionary.</span>
<span class="sd">            &#39;params&#39; may be empty.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; fname = os.path.join(os.path.expanduser(&#39;~&#39;), &#39;.fringes.yaml&#39;)</span>

<span class="sd">        &gt;&gt;&gt; import fringes as frng</span>
<span class="sd">        &gt;&gt;&gt; f = frng.Fringes()</span>

<span class="sd">        &gt;&gt;&gt; f.load(fname)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">),</span> <span class="s2">&quot;.fringes.yaml&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File &#39;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&#39; does not exist.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.asdf&quot;</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">asdf</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.json&quot;</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.yaml&quot;</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.toml&quot;</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">toml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown file type &#39;</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="s2">&quot;fringes&quot;</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;fringes&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded parameters from &#39;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No &#39;fringes&#39; section in file &#39;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="Fringes.save"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the parameters of the &#39;Fringes&#39; instance to a config file.</span>

<span class="sd">        Within the file, the parameters are written to the section `fringes`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str, optional</span>
<span class="sd">            File name of the file to save.</span>
<span class="sd">            Supported file formats are: *.json, *.yaml, *.toml, *.asdf.</span>
<span class="sd">            If `fname` is not provided, the parameters are saved to</span>
<span class="sd">            the file `.fringes.yaml` within the user home directory.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; fname = os.path.join(os.path.expanduser(&#39;~&#39;), &#39;.fringes.yaml&#39;)</span>

<span class="sd">        &gt;&gt;&gt; import fringes as frng</span>
<span class="sd">        &gt;&gt;&gt; f = frng.Fringes()</span>

<span class="sd">        &gt;&gt;&gt; f.save(fname)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">),</span> <span class="s2">&quot;.fringes.yaml&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File directory does not exist.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loader</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File extension is unknown. Must be one of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_loaders</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.asdf&quot;</span><span class="p">:</span>
            <span class="n">asdf</span><span class="o">.</span><span class="n">AsdfFile</span><span class="p">({</span><span class="s2">&quot;fringes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">})</span><span class="o">.</span><span class="n">write_to</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.json&quot;</span><span class="p">:</span>
                    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s2">&quot;fringes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">},</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.yaml&quot;</span><span class="p">:</span>
                    <span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s2">&quot;fringes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">},</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s2">&quot;.toml&quot;</span><span class="p">:</span>
                    <span class="n">toml</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s2">&quot;fringes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">},</span> <span class="n">f</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved parameters to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>  <span class="c1"># todo: info?</span></div>

<div class="viewcode-block" id="Fringes.reset"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset parameters of the &#39;Fringes&#39; instance to default values.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reset parameters to defaults.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fringes.optimize"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.optimize">[docs]</a>    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">umax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optimize the parameters of the &#39;Fringes&#39; instance.</span>

<span class="sd">         Parameters</span>
<span class="sd">         ----------</span>
<span class="sd">         T : int, optional</span>
<span class="sd">            Number of frames.</span>
<span class="sd">            If &#39;T&#39; is not provided, the number of frames from the &#39;Fringes&#39; instance is used.</span>
<span class="sd">            Then, the &#39;Fringes&#39; instance&#39;s number of shifts &#39;N&#39; is distributed optimally over the</span>

<span class="sd">         umax : float, optional</span>
<span class="sd">            Maximum allowable uncertainty.</span>
<span class="sd">            Must be greater than zero.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If &#39;umax&#39; is specified, the parameters are determined</span>
<span class="sd">        that allow a maximal uncertainty of &#39;umax&#39;</span>
<span class="sd">        with a minimum number of frames.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lopt</span><span class="p">)</span>  <span class="c1"># lopt ** K = L</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="s2">&quot;optimal&quot;</span>

        <span class="k">if</span> <span class="n">umax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># umax -&gt; T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>  <span class="c1"># make N const.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">umax</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># T -&gt; u</span>
            <span class="k">if</span> <span class="n">T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span>  <span class="c1"># distribute frames optimally (evenly) on shifts</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Optimized parameters.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fringes.gamma_auto_correct"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.gamma_auto_correct">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">gamma_auto_correct</span><span class="p">(</span><span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically estimate and apply the gamma correction factor</span>
<span class="sd">        to linearize the display/camera response curve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Recorded data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        J : np.ndarray</span>
<span class="sd">            Linearized data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># normalize to [0, 1]</span>
        <span class="n">Imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">I</span> <span class="o">/</span> <span class="n">Imax</span>

        <span class="c1"># estimate gamma correction factor</span>
        <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>  <span class="c1"># Median is a robust estimator for the mean.</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">med</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">inv_gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span>

        <span class="c1"># apply inverse gamma</span>
        <span class="c1"># table = np.array([((g / self.Imax) ** invGamma) * self.Imax for g in range(self.Imax + 1)], self.dtype)</span>
        <span class="c1"># J = cv2.LUT(J, table)</span>
        <span class="n">J</span> <span class="o">**=</span> <span class="n">inv_gamma</span>
        <span class="n">J</span> <span class="o">*=</span> <span class="n">Imax</span>

        <span class="k">return</span> <span class="n">J</span></div>

<div class="viewcode-block" id="Fringes.deinterlace"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.deinterlace">[docs]</a>    <span class="k">def</span> <span class="nf">deinterlace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deinterlace fringe patterns.</span>

<span class="sd">        The is for fringe patterns</span>
<span class="sd">        which were acquired with a line scan camera</span>
<span class="sd">        while each frame has been displayed and captured</span>
<span class="sd">        while the object was moving by one pixel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Fringe pattern sequence.</span>
<span class="sd">            It is reshaped to videoshape (frames &#39;T&#39;, height &#39;Y&#39;, width &#39;X&#39;, color channels &#39;C&#39;) before processing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Deinterlaced fringe pattern sequence.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the number of frames of &#39;I&#39; and the attribute &#39;T&#39; of the &#39;Fringes&#39; instance don&#39;t match.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import fringes as frng</span>
<span class="sd">        &gt;&gt;&gt; f = frng.Fringes()</span>
<span class="sd">        &gt;&gt;&gt; I = f.deinterlace(I)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">T</span> <span class="o">*</span> <span class="n">Y</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Number of frames of parameters and data don&#39;t match.&quot;</span>

        <span class="c1"># I = I.reshape((T * Y, X, C))  # concatenate</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">I</span></div>

<div class="viewcode-block" id="Fringes.coordinates"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the coordinate matrices of the coordinate system defined in `grid`.&quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">sys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;img&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span>
            <span class="k">else</span> <span class="s2">&quot;cart&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="s2">&quot;Cartesian&quot;</span>
            <span class="k">else</span> <span class="s2">&quot;pol&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="s2">&quot;polar&quot;</span>
            <span class="k">else</span> <span class="s2">&quot;logpol&quot;</span>
        <span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">sys</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">))[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">...</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;polar&quot;</span><span class="p">,</span> <span class="s2">&quot;log-polar&quot;</span><span class="p">]:</span>
            <span class="n">xi</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_orders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate fringe orders.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : np.ndarray</span>
<span class="sd">            Fringe orders of the encoded fringe pattern sequence,</span>
<span class="sd">            in shape (D, K, Y, X), where</span>
<span class="sd">            D is number of dimensions, K is number of sets i.e. number of spatial frequencies, Y is height, X is width.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;precise&quot;</span><span class="p">:</span>  <span class="c1"># todo: decide for each pixel individually i.e. multiply with B later on</span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">**</span><span class="mi">2</span>
            <span class="p">)</span>  <span class="c1"># weights of phase measurements are their inverse variances (must be multiplied with m later on)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
            <span class="p">]</span>  <span class="c1"># the set with most precise phases</span>
        <span class="c1"># elif mode == &quot;robust&quot;:  # todo: &quot;exhaustive&quot;?</span>
        <span class="c1">#     NotImplemented  # todo: try neighboring fringe orders / all permutations = exhaustive search?</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># fast (fallback)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
            <span class="p">]</span>  <span class="c1"># the set with the least number of periods</span>

        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)])[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_modulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frames</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encode base fringe patterns by spatio-temporal modulation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frames : None or int or tuple of ints, optional</span>
<span class="sd">            Indices of the frame or frames to be encoded.</span>
<span class="sd">            The default, frames=None, will encode all frames at once.</span>
<span class="sd">            If frames is negative, it counts from the last to the first frame.</span>
<span class="sd">            If frames contains numbers whose magnitude is larger than the total number of frames</span>
<span class="sd">            (as specified by the attribute &#39;T&#39; of the Fringes instance), it is wrapped around.</span>
<span class="sd">            If frames is a tuple of ints, only the frames specified in the tuple are encoded.</span>
<span class="sd">        rint : bool, optional</span>
<span class="sd">            If this is set to True (the default)</span>
<span class="sd">            and the used dtype (attribute &#39;dtype&#39; of the Fringes instance) is of type interger,</span>
<span class="sd">            the encoded patterns will be rounded to the nearest integer.</span>
<span class="sd">            If this is set False and the used dtype is of type interger,</span>
<span class="sd">            the fractional part of the encoded patterns will be discarded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Base fringe patterns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># dd = [d for d in range(self.D) for k in range(self.K) for n in range(self._N[d, k])]</span>
        <span class="c1"># kk = [k for d in range(self.D) for k in range(self.K) for n in range(self._N[d, k])]</span>
        <span class="c1"># NN = [self._N[d, k] for d in range(self.D) for k in range(self.K) for n in range(self._N[d, k])]</span>
        <span class="c1"># nn = [n for d in range(self.D) for k in range(self.K) for n in range(self._N[d, k])]</span>
        <span class="c1"># nn = np.array([n for N in self._N[dd, kk] for n in range(N)])</span>
        <span class="c1"># return = [(d, k) for d in range(self.D) for k in range(self.K) for n in range(self._N[d, k])][t]</span>

        <span class="c1"># Nacc = np.cumsum(self._N.ravel()).reshape((self.D, self.K))</span>
        <span class="c1"># return np.unravel_index(np.argmax(t &lt; Nacc), Nacc.shape)  # t &lt; Nacc  # argmax @bool: first element of True</span>

        <span class="c1"># Nacc = 0</span>
        <span class="c1"># for d in range(self.D):</span>
        <span class="c1">#     for k in range(self.K):</span>
        <span class="c1">#         Nacc += self._N[d, k]</span>
        <span class="c1">#         if t &lt; Nacc:</span>
        <span class="c1">#             return d, k</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># ensure frames is iterable</span>
            <span class="n">T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">frames</span><span class="p">]</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">!=</span> <span class="s2">&quot;image&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;uv-coordinates are not three-dimensional with shape (D, Y, X)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xi</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>  <span class="c1"># gets broadcasted</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">n</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="p">)))</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>

                        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span> <span class="ow">and</span> <span class="n">rint</span><span class="p">:</span>
                            <span class="c1"># val += .5</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">val</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="mf">0.5</span>

                        <span class="n">I</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

                        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># dt = np.float64 if self.SDM or self.FDM or np.any((self.h != 0) * (self.h != 255)) else self.dtype</span>
        <span class="c1"># I = encode(dt, np.ones(1), frames, self._N, self._v, self._f * (-1 if self.reverse else 1), self.o, self.Y, self.X, 1, self.axis, self.gamma, self.A, self.B)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_demodulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ski&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decode base fringe patterns by spatio-temporal demodulation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Fringe pattern sequence.</span>
<span class="sd">            It is reshaped to videoshape (frames &#39;T&#39;, height &#39;Y&#39;, width &#39;X&#39;, color channels &#39;C&#39;) before processing.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If this or the argument &#39;verbose&#39; of the Fringes instance is set to True,</span>
<span class="sd">            additional infomation is computed and retuned.</span>
<span class="sd">            This includes: phase maps, residuals, fringe orders, visibility and relative exposure.</span>

<span class="sd">        func : str, optional</span>
<span class="sd">            Unwrapping function to use. The default is &#39;ski&#39;.</span>

<span class="sd">            - &#39;ski&#39;: `Scikit-image &lt;https://scikit-image.org/docs/stable/auto_examples/filters/plot_phase_unwrap.html&gt;`_</span>

<span class="sd">            - else: `OpenCV https://docs.opencv.org/4.7.0/df/d3a/group__phase__unwrapping.html&gt;`_</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        brightness : np.ndarray</span>
<span class="sd">            Local background signal.</span>

<span class="sd">        modulation : np.ndarray</span>
<span class="sd">            Local amplitude of the cosine signal.</span>

<span class="sd">        registration : np.ndarray</span>
<span class="sd">            Decoded coordinates.</span>

<span class="sd">            .. note:: The registration is a mapping in the same pixel grid as the camera sensor</span>
<span class="sd">              and contains the information where each camera pixel, i.e. each camera sightray,</span>
<span class="sd">              was looking at during the fringe pattern acquisition.</span>

<span class="sd">        phase : np.ndarray, optional</span>
<span class="sd">            Local phase.</span>

<span class="sd">        orders : np.ndarray, optional</span>
<span class="sd">            Fringe orders.</span>

<span class="sd">        residuals : np.ndarray, optional</span>
<span class="sd">            Residuals from the optimization-based unwrapping process.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># parse</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># extract Y, X, C from data as these parameters depend on used camera</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

        <span class="c1"># if self.FDM:</span>
        <span class="c1">#    c = np.fft.rfft(I, axis=0) / T  # todo: hfft</span>
        <span class="c1">#</span>
        <span class="c1">#    # if np.any(self._N &gt; 2 * self.D * self.K):  # 2 * np.abs(_f).max() + 1:</span>
        <span class="c1">#    #     i = np.append(np.zeros(1, int), self._f.flatten().astype(int, copy=False))  # add offset</span>
        <span class="c1">#    #     c = c[i]</span>
        <span class="c1">#</span>
        <span class="c1">#    a = abs(c)</span>
        <span class="c1">#    # i = np.argsort(a[1:], axis=0)[::-1]  # indices of frequencies, sorted by their magnitude</span>
        <span class="c1">#    phi = -np.angle(c * np.exp(-1j * (self.o - np.pi)))[_f.flatten().astype(int, copy=False)]  # todo: why offset - PI???</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FTM</span><span class="p">:</span>
            <span class="c1"># todo: make passband symmetrical around carrier frequency?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>  <span class="c1"># todo: hfft</span>
                <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
                <span class="n">fxx</span><span class="p">,</span> <span class="n">fyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">)</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">fyy</span>
                <span class="p">)</span>  <span class="c1"># mask for x-frequencies  # todo: make left and right borders round (symmetrical around base band)</span>
                <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">fyy</span>
                <span class="p">)</span>  <span class="c1"># mask for y-frequencies  # todo: make lower and upper borders round (symmetrical around base band)</span>

                <span class="n">W</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># assume window width for filtering out baseband</span>
                <span class="n">W</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">W</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>  <span class="c1"># clip to ensure plausible value</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">W</span><span class="p">),</span> <span class="n">X</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># todo: find good upper cut off frequency</span>
                <span class="c1"># a = X // 4</span>
                <span class="n">mx</span><span class="p">[:,</span> <span class="p">:</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># remove high frequencies</span>
                <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">W</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">mx</span><span class="p">[:,</span> <span class="n">b</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># remove baseband and positive frequencies</span>

                <span class="n">H</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># assume window height for filtering out baseband</span>
                <span class="n">H</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>  <span class="c1"># clip to ensure plausible value</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="n">Y</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>  <span class="c1"># todo: find good upper cut off frequency</span>
                <span class="c1"># c = Y // 4</span>
                <span class="n">my</span><span class="p">[:</span><span class="n">c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># remove high frequencies</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Y</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">H</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">my</span><span class="p">[</span><span class="n">d</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># remove baseband and positive frequencies</span>

                <span class="c1"># todo: smooth edges of filter masks, i.e. make them Hann Windows</span>

                <span class="k">if</span> <span class="n">C</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># if self.verbose:</span>
                <span class="c1">#     phi = np.empty([self.D, Y, X, C], np.float32)</span>
                <span class="c1">#     res = np.empty([self.D, Y, X, C], np.float32)</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">bri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">fid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                    <span class="c1"># todo: hfft</span>
                    <span class="n">I_FFT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]))</span>

                    <span class="n">I_FFT_x</span> <span class="o">=</span> <span class="n">I_FFT</span> <span class="o">*</span> <span class="n">mx</span>
                    <span class="n">ixy</span><span class="p">,</span> <span class="n">ixx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">I_FFT_x</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="n">I_FFT_x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># get indices of carrier frequency</span>
                    <span class="n">I_FFT_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">I_FFT_x</span><span class="p">,</span> <span class="n">X</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ixx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># move to center</span>

                    <span class="n">I_FFT_y</span> <span class="o">=</span> <span class="n">I_FFT</span> <span class="o">*</span> <span class="n">my</span>
                    <span class="n">iyy</span><span class="p">,</span> <span class="n">iyx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">I_FFT_y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="n">I_FFT_y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># get indices of carrier frequency</span>
                    <span class="n">I_FFT_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">I_FFT_y</span><span class="p">,</span> <span class="n">Y</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">iyy</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># move to center</span>

                    <span class="n">Jx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT_x</span><span class="p">))</span>
                    <span class="n">Jy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT_y</span><span class="p">))</span>

                    <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">Jx</span><span class="p">)</span>
                    <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">Jy</span><span class="p">)</span>
                    <span class="c1"># todo: bri</span>
                    <span class="n">mod</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Jx</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># factor 2 because one sideband is filtered out</span>
                    <span class="n">mod</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Jy</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># factor 2 because one sideband is filtered out</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                        <span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_FFT</span><span class="p">))</span>  <span class="c1"># J  # todo: hfft</span>
                        <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_FFT</span><span class="p">))</span>  <span class="c1"># J</span>
                        <span class="c1"># todo: I - J</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
                <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="o">*</span> <span class="n">X</span> <span class="o">*</span> <span class="n">Y</span> <span class="o">/</span> <span class="n">L</span>  <span class="c1"># todo: hfft</span>
                <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span> <span class="o">*</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">X</span> <span class="o">/</span> <span class="n">L</span>
                <span class="n">fxx</span><span class="p">,</span> <span class="n">fyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">)</span>
                <span class="n">frr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fxx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">fyy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># todo: normalization of both directions</span>

                <span class="n">mr</span> <span class="o">=</span> <span class="n">frr</span> <span class="o">&lt;=</span> <span class="n">L</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># ensure same sampling in all directions</span>
                <span class="n">W</span> <span class="o">=</span> <span class="mi">10</span>
                <span class="n">W</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">W</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">L</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
                <span class="n">mr</span><span class="p">[</span><span class="n">frr</span> <span class="o">&lt;</span> <span class="n">W</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># remove baseband</span>
                <span class="n">mr</span><span class="p">[</span><span class="n">frr</span> <span class="o">&gt;</span> <span class="n">L</span> <span class="o">/</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># remove too high frequencies</span>

                <span class="n">mh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">])</span>
                <span class="n">mh</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">X</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">mh</span><span class="p">[:,</span> <span class="n">X</span> <span class="o">//</span> <span class="mi">2</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">C</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">fid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">bri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                    <span class="c1"># todo: hfft</span>
                    <span class="n">I_FFT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]))</span>

                    <span class="n">I_FFT_r</span> <span class="o">=</span> <span class="n">I_FFT</span> <span class="o">*</span> <span class="n">mr</span>
                    <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">I_FFT_r</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(),</span> <span class="n">I_FFT_r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># get indices of carrier frequency</span>
                    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">iy</span><span class="p">,</span> <span class="n">X</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ix</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="n">mhr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">reshape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

                    <span class="n">I_FFT_r</span> <span class="o">*=</span> <span class="n">mhr</span>  <span class="c1"># remove one sideband</span>
                    <span class="n">I_FFT_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">I_FFT_r</span><span class="p">,</span> <span class="n">X</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># move to center</span>
                    <span class="n">I_FFT_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">I_FFT_r</span><span class="p">,</span> <span class="n">Y</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">iy</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># move to center</span>

                    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT_r</span><span class="p">))</span>

                    <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
                    <span class="c1"># todo: bri</span>
                    <span class="n">mod</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># factor 2 because one sideband is filtered out</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_FFT</span><span class="p">))</span>  <span class="c1"># J</span>
                        <span class="c1"># todo: I - J</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;fast&quot;</span><span class="p">:</span>
                <span class="n">SQNR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># todo: 0.5 or self.u</span>
                <span class="c1"># todo: r[d] for d in range(self.D)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># todo</span>

            <span class="c1"># # time/frame indices for when decoding shifts of each set</span>
            <span class="c1"># Nacc = np.cumsum(self._N.ravel()).reshape(self.D, self.K)</span>
            <span class="c1"># N0 = np.array([[0], [Nacc[0, -1]]])[: self.D]</span>
            <span class="c1"># ti = np.concatenate((N0, Nacc), axis=1).astype(np.int_)  # indices for traversing t</span>
            <span class="c1">#</span>
            <span class="c1"># dt = np.float32</span>
            <span class="c1"># A = np.empty((self.D, Y, X, C), dt)</span>
            <span class="c1"># B = np.empty((self.D, self.K, Y, X, C), dt)</span>
            <span class="c1"># x = np.empty((self.D, Y, X, C), dt)</span>
            <span class="c1"># p = np.empty((self.D, self.K, Y, X, C), dt)</span>
            <span class="c1"># if self.verbose or verbose:</span>
            <span class="c1">#     r = np.empty((self.D, Y, X, C), dt)</span>
            <span class="c1">#     k = np.empty((self.D, self.K, Y, X, C), dt)</span>
            <span class="c1"># for d in range(self.D):</span>
            <span class="c1">#     A[d] = np.mean(I[: np.sum(self._N[d])])</span>
            <span class="c1">#     for i in range(self.K):</span>
            <span class="c1">#         t = np.arange(self._N[d, i]) / self._N[d, i]  # sampling points i.e. normalized time coordinates</span>
            <span class="c1">#         # t = n / 4 if N[d, k] == 2 else n / N[d, k]  # todo: variable/individual t as in Uni-PSA-Gen</span>
            <span class="c1">#         c = np.exp(1j * 2 * np.pi * self._f[d, i] * t)</span>
            <span class="c1">#         z = np.sum(c[:, None, None, None] * I[ti[d, i] : ti[d, i + 1]], axis=0)</span>
            <span class="c1">#         B[d] = np.abs(z) / self._N[d, i] * 2</span>
            <span class="c1">#         p[d] = np.angle(z)</span>
            <span class="c1">#</span>
            <span class="c1">#     if self.K == 1:</span>
            <span class="c1">#         if self._v[d, 0] == 0:  # no spatial modulation</span>
            <span class="c1">#             if self.R[d] == 1:</span>
            <span class="c1">#                 x[</span>
            <span class="c1">#                     d</span>
            <span class="c1">#                 ] = 0  # the only possible value; however this is obsolete as it makes no senso to encode only one single coordinate</span>
            <span class="c1">#                 if self.verbose or verbose:</span>
            <span class="c1">#                     r[d] = 0</span>
            <span class="c1">#                     k[d] = 0</span>
            <span class="c1">#             else:</span>
            <span class="c1">#                 x[d] = np.nan  # no spatial modulation, therefore we can&#39;t compute value</span>
            <span class="c1">#                 if self.verbose or verbose:</span>
            <span class="c1">#                     r[d] = np.nan</span>
            <span class="c1">#                     k[d] = np.nan</span>
            <span class="c1">#         elif self._v[d, 0] &lt;= 1:  # one period covers whole screen: no unwrapping required</span>
            <span class="c1">#             x[d] = (</span>
            <span class="c1">#                 (p[d, 0] + self.o) / (2 * np.pi) % 1 * self._l[d, 0]</span>
            <span class="c1">#             )  # revert offset and change codomain from [-PI, PI] to [0, 1) -&gt; normalized phi</span>
            <span class="c1">#             if self.verbose or verbose:</span>
            <span class="c1">#                 r[d] = 0  # todo: uncertainty</span>
            <span class="c1">#                 k[d] = 0</span>
            <span class="c1">#         else:  # spatial phase unwrapping</span>
            <span class="c1">#             if func in &quot;cv2&quot;:  # OpenCV unwrapping</span>
            <span class="c1">#                 # params = cv2.phase_unwrapping_HistogramPhaseUnwrapping_Params()</span>
            <span class="c1">#                 params = cv2.phase_unwrapping.HistogramPhaseUnwrapping.Params()</span>
            <span class="c1">#                 params.height = Y</span>
            <span class="c1">#                 params.width = X</span>
            <span class="c1">#                 # unwrapping_instance = cv2.phase_unwrapping.HistogramPhaseUnwrapping_create(params)</span>
            <span class="c1">#                 unwrapping_instance = cv2.phase_unwrapping.HistogramPhaseUnwrapping.create(params)</span>
            <span class="c1">#</span>
            <span class="c1">#             #     if self.K == 1:  # todo: self.K[d] == 1</span>
            <span class="c1">#             #         self.logger.info(f&quot;Spatial phase unwrapping in 2D{&#39; for each color indepently&#39; if C &gt; 1 else &#39;&#39;}.&quot;)</span>
            <span class="c1">#             #     else:</span>
            <span class="c1">#             #         self.logger.info(f&quot;Spatial phase unwrapping in 3D{&#39; for each color indepently&#39; if C &gt; 1 else &#39;&#39;}.&quot;)</span>
            <span class="c1">#             #         func = &quot;ski&quot;  # todo: 3D SPU with OpenCV?</span>
            <span class="c1">#</span>
            <span class="c1">#             for c in range(C):</span>
            <span class="c1">#                 if (</span>
            <span class="c1">#                     func in &quot;cv2&quot;</span>
            <span class="c1">#                 ):  # OpenCV algorithm is usually faster, but can be much slower in noisy images</span>
            <span class="c1">#                     # dtype of p must be np.float32  # todo: test this</span>
            <span class="c1">#                     if mask:</span>
            <span class="c1">#                         SNR = self.B[d, :, :, c] / self.ui</span>
            <span class="c1">#                         upi = (</span>
            <span class="c1">#                             np.sqrt(2) / np.sqrt(self.M) / np.sqrt(self._N) / SNR</span>
            <span class="c1">#                         )  # local phase uncertainties</span>
            <span class="c1">#                         upin = upi / (2 * np.pi)  # normalized local phase uncertainty</span>
            <span class="c1">#                         uxi = upin * self._l  # local positional uncertainties</span>
            <span class="c1">#                         ux = np.sqrt(1 / np.sum(1 / uxi**2))</span>
            <span class="c1">#                         mask = np.astype(ux &lt; 0.5, copy=False)  # todo: which limit?</span>
            <span class="c1">#                         x[d, :, :, c] = unwrapping_instance.unwrapPhaseMap(</span>
            <span class="c1">#                             p[d, 0, :, :, c], mask</span>
            <span class="c1">#                         )  # todo: test this</span>
            <span class="c1">#</span>
            <span class="c1">#                         xmin = np.min(x[d, :, :, c])</span>
            <span class="c1">#                         if xmin &lt; 0:</span>
            <span class="c1">#                             x[d, :, :, c] -= xmin</span>
            <span class="c1">#                     else:</span>
            <span class="c1">#                         x[d, :, :, c] = unwrapping_instance.unwrapPhaseMap(p[d, 0, :, :, c])</span>
            <span class="c1">#</span>
            <span class="c1">#                         xmin = np.min(x[d, :, :, c])</span>
            <span class="c1">#                         if xmin &lt; 0:</span>
            <span class="c1">#                             x[d, :, :, c] -= xmin</span>
            <span class="c1">#</span>
            <span class="c1">#                     if self.verbose or verbose:</span>
            <span class="c1">#                         r[d, :, :, c] = unwrapping_instance.getInverseReliabilityMap()  # todo: test this</span>
            <span class="c1">#                         # todo: res vs. rel</span>
            <span class="c1">#                 else:  # Scikit-image algorithm is usually slower, but delivers better results on edges</span>
            <span class="c1">#                     x[d, :, :, c] = ski.restoration.unwrap_phase(p[d, 0, :, :, c])  # todo: res</span>
            <span class="c1">#</span>
            <span class="c1">#             x[d] *= 1 / (2 * np.pi) * self._l[d, 0]</span>
            <span class="c1">#</span>
            <span class="c1">#             if self.verbose or verbose:</span>
            <span class="c1">#                 k[d, 0] = np.nan  # unknown</span>
            <span class="c1">#     else:  # K &gt; 1: temporal phase unwrapping</span>
            <span class="c1">#         if self.mode == &quot;fast&quot;:</span>
            <span class="c1">#             w = np.ones(self.K, np.uint8)</span>
            <span class="c1">#             i0 = np.argmin(self._v[d])</span>
            <span class="c1">#         else:</span>
            <span class="c1">#             w = 1 / self._v[d] / np.sqrt(self._N[d])  # todo: M, B</span>
            <span class="c1">#             i0 = np.argmin(w, axis=0)</span>
            <span class="c1">#         w = w / np.sum(w, axis=0)</span>
            <span class="c1">#         vmax = np.ceil(self._v[d, i0] / self.alpha).astype(int)</span>
            <span class="c1">#</span>
            <span class="c1">#         # C = sp.special.comb(n, self.K, exact=True)  # number of unique combinations</span>
            <span class="c1">#         # combos = it.combinations(range(lmin, lmax + 1), self.K)</span>
            <span class="c1">#         mn = np.inf</span>
            <span class="c1">#         pn = (p[d] % (2 * np.pi) + self.o) / (2 * np.pi) % 1  # shape = (K, Y, X, C)</span>
            <span class="c1">#</span>
            <span class="c1">#         for k in range(vmax):</span>
            <span class="c1">#             xi0 = (k + pn[i0]) * self._l[d, i0]</span>
            <span class="c1">#             s = xi0</span>
            <span class="c1">#             ssd = xi0**2</span>
            <span class="c1">#</span>
            <span class="c1">#             for i in it.chain(range(0, i0), range(i0 + 1, 1)):</span>
            <span class="c1">#                 j = (xi0 / self._d[d, i]).astype(int)</span>
            <span class="c1">#                 xj = (j + pn[i]) * self._l[d]</span>
            <span class="c1">#                 s += xj</span>
            <span class="c1">#                 ssd += xj**2</span>
            <span class="c1">#</span>
            <span class="c1">#             ssd -= s**2 / self.K</span>
            <span class="c1">#</span>
            <span class="c1">#             np.minimum(mn, ssd, out=mn)</span>
            <span class="c1">#</span>
            <span class="c1">#         q = 1</span>

            <span class="n">phi</span><span class="p">,</span> <span class="n">bri</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">fid</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span>
                <span class="n">I</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">,</span>
                <span class="n">_f</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="p">,</span>
                <span class="n">r</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umin</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bri</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_multiplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">rint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multiplex fringe patterns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Base fringe patterns.</span>
<span class="sd">        rint : bool, optional</span>
<span class="sd">            If this is set to True (the default)</span>
<span class="sd">            and the used dtype (attribute &#39;dtype&#39; of the Fringes instance) is of type interger,</span>
<span class="sd">            the encoded patterns will be rounded to the nearest integer.</span>
<span class="sd">            If this is set False and the used dtype is of type interger,</span>
<span class="sd">            the fractional part of the encoded patterns will be discarded.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Multiplexed fringe patterns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ismono</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># returns a view</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># returns a view</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">))</span>  <span class="c1"># returns a view</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">assert</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span>

            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># returns a view</span>
            <span class="n">I</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
            <span class="c1"># I *= 1 / self.D</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="k">else</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># returns a view</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;uib&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rint</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">I</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># returns a view</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># todo: fractional periods</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Decoding might be disturbed.&quot;</span><span class="p">)</span>

            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># returns a view</span>
            <span class="n">I</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
            <span class="c1"># I *= 1 / (self.D * self.K)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># returns a view</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;uib&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rint</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">I</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># returns a view</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">I</span>

    <span class="k">def</span> <span class="nf">_demultiplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Demultiplex fringe patterns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Multiplexed fringe patterns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Demultiplexed fringe patterns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">X</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
                <span class="n">fxx</span><span class="p">,</span> <span class="n">fyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">)</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fyy</span><span class="p">)</span>
                <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fyy</span><span class="p">)</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">I</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                        <span class="n">I_FFT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft2</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]))</span>
                        <span class="n">I</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT</span> <span class="o">*</span> <span class="n">mx</span><span class="p">))</span>
                        <span class="n">I</span><span class="p">[</span><span class="n">T</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT</span> <span class="o">*</span> <span class="n">my</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">Y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
                <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="n">fxx</span><span class="p">,</span> <span class="n">fyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">)</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fyy</span><span class="p">)</span>
                <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fyy</span><span class="p">)</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                        <span class="n">I_FFT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft2</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]))</span>
                        <span class="n">I</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT</span> <span class="o">*</span> <span class="n">my</span><span class="p">))</span>
                        <span class="n">I</span><span class="p">[</span><span class="n">T</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT</span> <span class="o">*</span> <span class="n">mx</span><span class="p">))</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
                <span class="n">fxx</span><span class="p">,</span> <span class="n">fyy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">)</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fyy</span><span class="p">)</span>
                <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fyy</span><span class="p">)</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">I</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                        <span class="n">I_FFT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]))</span>
                        <span class="n">I</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT</span> <span class="o">*</span> <span class="n">mx</span><span class="p">)))</span>
                        <span class="n">I</span><span class="p">[</span><span class="n">T</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">I_FFT</span> <span class="o">*</span> <span class="n">my</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span>
            <span class="k">assert</span> <span class="n">C</span> <span class="o">==</span> <span class="mi">3</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>  <span class="c1"># returns a view</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># returns a view</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># returns a view</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span>  <span class="c1"># todo: allow self.SDM?</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">I</span>

    <span class="k">def</span> <span class="nf">_colorize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">frames</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Colorize fringe patterns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Base fringe patterns.</span>
<span class="sd">        frames : None or int or tuple of ints, optional</span>
<span class="sd">            Indices of the frame or frames to be encoded.</span>
<span class="sd">            The default, frames=None, will encode all frames at once.</span>
<span class="sd">            If frames is negative, it counts from the last to the first frame.</span>
<span class="sd">            If frames contains numbers whose magnitude is larger than the total number of frames</span>
<span class="sd">            (as specified by the attribute &#39;T&#39; of the Fringes instance), it is wrapped around.</span>
<span class="sd">            If frames is a tuple of ints, only the frames specified in the tuple are encoded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Colorized fringe patterns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">Th</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># number of framess for each hue</span>

        <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hues</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">):</span>
                    <span class="n">cj</span> <span class="o">=</span> <span class="n">c</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># uib -&gt; uib, f -&gt; f</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">h</span> <span class="o">*</span> <span class="n">Th</span> <span class="p">:</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Th</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">255</span> <span class="ow">and</span> <span class="n">J</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>  <span class="c1"># uib -&gt; uib, f -&gt; f</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">h</span> <span class="o">*</span> <span class="n">Th</span> <span class="p">:</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Th</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cj</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;uib&quot;</span><span class="p">:</span>  <span class="c1"># f -&gt; uib</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">h</span> <span class="o">*</span> <span class="n">Th</span> <span class="p">:</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Th</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cj</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># f -&gt; f</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">h</span> <span class="o">*</span> <span class="n">Th</span> <span class="p">:</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Th</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cj</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">255</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hues</span><span class="p">:</span>  <span class="c1"># i.e. frames is not None and h in hues</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">):</span>
                    <span class="n">cj</span> <span class="o">=</span> <span class="n">c</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># uib -&gt; uib, f -&gt; f</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">255</span> <span class="ow">and</span> <span class="n">J</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>  <span class="c1"># uib -&gt; uib, f -&gt; f</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cj</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;uib&quot;</span><span class="p">:</span>  <span class="c1"># f -&gt; uib</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cj</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># f -&gt; f</span>
                        <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cj</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">255</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">J</span>

    <span class="k">def</span> <span class="nf">_decolorize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decolorize fringe patterns i.e. fuse hues/colors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Colorized fringe patterns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Decolorized fringe patterns.&quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">T</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>  <span class="c1"># returns a view</span>

        <span class="n">is_base</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>  <span class="c1"># every hue consists of only one of the RGB base colors</span>
        <span class="n">is_single</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># each RGB color exists only once</span>
        <span class="n">is_single_and_value</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">T</span>
        <span class="p">)</span>  <span class="c1"># each RGB color exists only once and is natural</span>
        <span class="n">is_equal_or_zero</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># all colors are equal or zero</span>
        <span class="c1"># if is_base and is_single or is_single_and_value: no averaging necessary</span>
        <span class="c1"># if is_equal_or_zero: no weights necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">and</span> <span class="n">is_base</span> <span class="ow">and</span> <span class="n">is_single</span> <span class="ow">and</span> <span class="n">is_equal_or_zero</span><span class="p">:</span>  <span class="c1"># pure RGB colors</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># returns a view</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>  <span class="c1"># RGB</span>
                <span class="c1"># I = I[..., :, :]</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>  <span class="c1"># RBG</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>  <span class="c1"># GBR</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>  <span class="c1"># GRB</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>  <span class="c1"># BGR</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>  <span class="c1"># BRG</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

            <span class="k">if</span> <span class="n">C</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">C</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># returns a view</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">C</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">is_single_and_value</span> <span class="ow">and</span> <span class="n">is_equal_or_zero</span>
        <span class="p">):</span>  <span class="c1"># todo: C == 3 avoids CMY colors appearing twice as bright as RGB colors (as it is with mono cameras) assuming spectral bands don&#39;t overlap</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># returns a view</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>  <span class="c1"># advanced indexing doesn&#39;t return a view</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># fuse colors by weighted averaging</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># normalized weights</span>
            <span class="c1"># w[np.isnan(w)] = 0</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>  <span class="c1"># todo: when does this happen?</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># multiplying with bool preserves dtype</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span>  <span class="c1"># without this, np.sum chooses a dtype which can hold the theoretical maximal sum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>  <span class="c1"># without this, np.sum chooses a dtype which can hold the theoretical maximal sum</span>

            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">I</span> <span class="o">*</span> <span class="n">w</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">I</span>

<div class="viewcode-block" id="Fringes.encode"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">frames</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">simulate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Encode fringe patterns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frames : None or int or tuple of ints, optional</span>
<span class="sd">            Indices of the frame or frames to be encoded.</span>
<span class="sd">            The default, frames=None, will encode all frames at once.</span>
<span class="sd">            If frames is negative, it counts from the last to the first frame.</span>
<span class="sd">            If frames contains numbers whose magnitude is larger than the total number of frames</span>
<span class="sd">            (as specified by the attribute &#39;T&#39; of the Fringes instance), it is wrapped around.</span>
<span class="sd">            If frames is a tuple of ints, only the frames specified in the tuple are encoded.</span>

<span class="sd">        rint : bool, optional</span>
<span class="sd">            If this is set to True (the default)</span>
<span class="sd">            and the used dtype (attribute &#39;dtype&#39; of the Fringes instance) is of type interger,</span>
<span class="sd">            the encoded patterns will be rounded to the nearest integer.</span>
<span class="sd">            If this is set False and the used dtype is of type interger,</span>
<span class="sd">            the fractional part of the encoded patterns will be discarded.</span>

<span class="sd">        simulate : bool, optional</span>
<span class="sd">            If this is set to True, the acquisition, i.e. the transmission channel, will be simulated.</span>
<span class="sd">            This includes the modulation transfer function</span>
<span class="sd">            (computed from the imaging system&#39;s point spread function)</span>
<span class="sd">            and intensity noise added by the camera.</span>
<span class="sd">            The required parameters for this are the instance&#39;s attributes</span>
<span class="sd">            &#39;magnification&#39;, &#39;PSF&#39;, &#39;system_gain&#39;, &#39;dark_current&#39; and &#39;dark_noise&#39;.</span>
<span class="sd">            Default. False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Fringe pattern sequence.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To receive the frames iteratively (i.e. in a lazy manner),</span>
<span class="sd">        simply iterate over the Fringes instance.</span>
<span class="sd">        Alternatively, to receive arbitrary frames,</span>
<span class="sd">        index the Fringes instance directly,</span>
<span class="sd">        either with an integer, a tuple or a slice.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import fringes as frng</span>
<span class="sd">        &gt;&gt;&gt; f = frng.Fringes()</span>

<span class="sd">        Encode the complete fringe pattern sequence.</span>

<span class="sd">        &gt;&gt;&gt; I = f.encode()</span>

<span class="sd">        Encode the first frame of the fringe pattern sequence.</span>

<span class="sd">        &gt;&gt;&gt; I = f.encode(frames=0)</span>
<span class="sd">        &gt;&gt;&gt; I = f[0]</span>
<span class="sd">        &gt;&gt;&gt; I = next(iter(f))</span>

<span class="sd">        Encode the last frame of the fringe pattern sequence.</span>

<span class="sd">        &gt;&gt;&gt; I = f.encode(frames=-1)</span>
<span class="sd">        &gt;&gt;&gt; I = f[-1]</span>

<span class="sd">        Encode the first two frames of the fringe pattern sequence.</span>

<span class="sd">        &gt;&gt;&gt; I = f.encode(frames=(0, 1))</span>
<span class="sd">        &gt;&gt;&gt; I = f[0, 1]</span>
<span class="sd">        &gt;&gt;&gt; I = f[:2]</span>

<span class="sd">        Create a generator to receive the frames iteratively, i.e. in a lazy manner.</span>

<span class="sd">        &gt;&gt;&gt; I = (frame for frame in f)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="c1"># check UMR</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isambiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;UMR &lt; R. Unwrapping will not be spatially independent and only yield a relative phase map.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># lazy encoding</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># ensure frames is iterable</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">frames</span><span class="p">]</span>

            <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span><span class="p">:</span>  <span class="c1"># WDM before SDM</span>
                <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span><span class="p">:</span>  <span class="c1"># WDM before SDM</span>
                <span class="n">EN0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">EN0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">EN0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># modulate</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modulate</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">rint</span><span class="p">)</span>

        <span class="c1"># multiplex (reduce number of frames)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplex</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">rint</span><span class="p">)</span>

        <span class="c1"># apply inscribed circle</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;polar&quot;</span><span class="p">,</span> <span class="s2">&quot;log-polar&quot;</span><span class="p">]:</span>
            <span class="n">I</span> <span class="o">*=</span> <span class="n">grid</span><span class="o">.</span><span class="n">innercirc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># colorize (extended averaging)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">255</span><span class="p">):</span>  <span class="c1"># can be used for extended averaging</span>
            <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colorize</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnification</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PSF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dark</span><span class="p">)</span> <span class="k">if</span> <span class="n">simulate</span> <span class="k">else</span> <span class="n">I</span></div>

<div class="viewcode-block" id="Fringes.decode"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.decode">[docs]</a>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">despike</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">denoise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">namedtuple</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Decode fringe patterns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Fringe pattern sequence.</span>
<span class="sd">            It is reshaped to videoshape (frames &#39;T&#39;, height &#39;Y&#39;, width &#39;X&#39;, color channels &#39;C&#39;) before processing.</span>

<span class="sd">            .. note:: It must have been encoded with the same parameters set to the Fringes instance as the encoded one.</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If this or the argument &#39;verbose&#39; of the Fringes instance is set to True,</span>
<span class="sd">            additional infomation is computed and retuned.</span>
<span class="sd">            This includes: phase, residuals, orders, visibility and exposure.</span>

<span class="sd">        despike: bool, optional</span>
<span class="sd">            If this is set to true, single pixel outliers in the unwrapped phase map are replaced</span>
<span class="sd">            by their local neighborhood using a median filter.</span>

<span class="sd">        denoise: bool, optional</span>
<span class="sd">            If this is set to True, the unwrapped phase map is smoothened</span>
<span class="sd">            by a bilateral filter which is edge-preserving.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        brightness : np.ndarray</span>
<span class="sd">            Local background signal.</span>

<span class="sd">        modulation : np.ndarray</span>
<span class="sd">            Local amplitude of the cosine signal.</span>

<span class="sd">        registration : np.ndarray</span>
<span class="sd">            Decoded coordinates.</span>

<span class="sd">            .. note:: The registration is a mapping in the same pixel grid as the camera sensor</span>
<span class="sd">              and contains the information where each camera pixel, i.e. each camera sightray,</span>
<span class="sd">              was looking at during the fringe pattern acquisition.</span>

<span class="sd">        phase : np.ndarray, optional</span>
<span class="sd">            Local phase.</span>

<span class="sd">        orders : np.ndarray, optional</span>
<span class="sd">            Fringe orders.</span>

<span class="sd">        residuals : np.ndarray, optional</span>
<span class="sd">            Residuals from the optimization-based unwrapping process.</span>

<span class="sd">        visibility : np.ndarray, optional</span>
<span class="sd">            Local visibility (fringe contrast).</span>

<span class="sd">        exposure : np.ndarray, optional</span>
<span class="sd">            Local exposure (relative average intensity).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the number of frames of &#39;I&#39; and the attribute &#39;T&#39; of the &#39;Fringes&#39; instance don&#39;t match.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import fringes as frng</span>
<span class="sd">        &gt;&gt;&gt; f = frng.Fringes()</span>
<span class="sd">        &gt;&gt;&gt; I = f.encode()</span>

<span class="sd">        &gt;&gt;&gt; A, B, x = f.decode(I)</span>

<span class="sd">        &gt;&gt;&gt; A, B, x, p, k, e, V, H = f.decode(I, verbose=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="c1"># get and apply videoshape</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># extract Y, X, C from data as these parameters depend on used camera</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

        <span class="c1"># assertions</span>
        <span class="k">assert</span> <span class="n">T</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;Number of frames of parameters and data don&#39;t match.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Shifts aren&#39;t equal.&quot;</span>

        <span class="c1"># subtract dark signal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">I</span><span class="p">[</span><span class="n">I</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">I</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span>
            <span class="n">I</span><span class="p">[</span><span class="n">I</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># decolorize i.e. fuse hues/colors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ismono</span><span class="p">:</span>  <span class="c1"># for gray fringes, color fusion is not performed, but extended averaging is</span>
            <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decolorize</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

        <span class="c1"># demultiplex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_demultiplex</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

        <span class="c1"># demodulate</span>
        <span class="n">bri</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_demodulate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="o">/</span> <span class="n">bri</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>  <span class="c1"># data may hold less bits of information</span>
                    <span class="n">mx</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

                    <span class="n">Imax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">max</span><span class="p">())))</span>  <span class="c1"># same or next power of two</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># float</span>
                <span class="n">Imax</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">bri</span> <span class="o">/</span> <span class="n">Imax</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>  <span class="c1"># blacken where color value of hue was black</span>
                <span class="n">reg</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">fid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># np.nan</span>

        <span class="c1"># spatial unwrapping</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isambiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unwrapping is not spatially independent and only yields a relative phase map.&quot;</span><span class="p">)</span>
            <span class="n">uwr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unwrap</span><span class="p">(</span><span class="n">phi</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose</span> <span class="k">else</span> <span class="n">reg</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">reg</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">fid</span> <span class="o">=</span> <span class="n">uwr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="n">uwr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># coordiante retransformation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="s2">&quot;Cartesian&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span>
                        <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span>

                <span class="c1"># todo: polar, logpolar</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">],</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span>
                        <span class="c1"># R = np.matrix([[c, -s], [s, c]])</span>
                        <span class="n">ur</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">vr</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="c1"># u = np.dot(uu, R)  # todo: matrix multiplication</span>
                        <span class="c1"># v = np.dot(vv, R)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">ur</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">vr</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

                    <span class="n">vv</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tan</span> <span class="o">-</span> <span class="n">tan</span><span class="p">)</span>
                    <span class="n">uu</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vv</span> <span class="o">*</span> <span class="n">tan</span>
                    <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">ur</span><span class="p">,</span> <span class="n">vr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">despike</span><span class="p">:</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

            <span class="c1"># reg[:, -1, -1, ...] = 0</span>
            <span class="c1"># reg[:, -10, -10, ...] = 0</span>
            <span class="c1"># points = np.arange(Y), np.arange(X)</span>
            <span class="c1"># for d in range(self.D):</span>
            <span class="c1">#     for c in range(C):</span>
            <span class="c1">#         spikes = np.abs(reg[d, :, :, c] - median(reg[d, :, :, c])[0, :, :, 0]) &gt; np.std(reg[d, :, :, c])  # bilateral</span>
            <span class="c1">#         values = reg[d, :, :, c]</span>
            <span class="c1">#         xi = np.nonzero(spikes)</span>
            <span class="c1">#         values[xi] = 0</span>
            <span class="c1">#         xi = np.argwhere(spikes)</span>
            <span class="c1">#         a = sp.interpolate.interpn(points, values, xi, method=&quot;cubic&quot;)</span>
            <span class="c1">#         reg[d] = sp.interpolate.interpn(points, values, xi, method=&quot;cubic&quot;)</span>

        <span class="k">if</span> <span class="n">denoise</span><span class="p">:</span>
            <span class="n">reg</span> <span class="o">=</span> <span class="n">bilateral</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># create named tuple to return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
                <span class="s2">&quot;decoded&quot;</span><span class="p">,</span>
                <span class="s2">&quot;brightness modulation registration phase orders residuals visibility exposure&quot;</span><span class="p">,</span>
            <span class="p">)(</span><span class="n">bri</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;decoded&quot;</span><span class="p">,</span> <span class="s2">&quot;brightness modulation registration&quot;</span><span class="p">)(</span><span class="n">bri</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dec</span></div>

    <span class="k">def</span> <span class="nf">_unwrap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ski&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">namedtuple</span><span class="p">:</span>  <span class="c1"># todo: use B for quality guidance</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unwrap phase maps spacially.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phi : np.ndarray</span>
<span class="sd">            Phase maps to unwrap spatially, stacked along the first dimension.</span>
<span class="sd">            It is reshaped to videoshape (frames &#39;T&#39;, height &#39;Y&#39;, width &#39;X&#39;, color channels &#39;C&#39;) before processing.</span>
<span class="sd">            The frames (along first dimension) as well the color channels (along last dimension)</span>
<span class="sd">            are unwrapped separately.</span>

<span class="sd">        mask : np.ndarray, optional</span>
<span class="sd">            Mask image with dtype &#39;np.uint8&#39; used when some pixels do not hold any phase information.</span>

<span class="sd">        func : str, optional</span>
<span class="sd">            Unwrapping function to use. The default is &#39;ski&#39;.</span>

<span class="sd">            - &#39;ski&#39;: `Scikit-image &lt;https://scikit-image.org/docs/stable/auto_examples/filters/plot_phase_unwrap.html&gt;`_</span>

<span class="sd">            - else: `OpenCV https://docs.opencv.org/4.7.0/df/d3a/group__phase__unwrapping.html&gt;`_</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unwrapped : np.ndarray</span>
<span class="sd">            Unwrapped phase map(s).&quot;&quot;&quot;</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">T</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Number of frames of parameters and data don&#39;t match.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="s2">&quot;cv2&quot;</span><span class="p">:</span>  <span class="c1"># OpenCV unwrapping</span>
            <span class="c1"># params = cv2.phase_unwrapping_HistogramPhaseUnwrapping_Params()</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">phase_unwrapping</span><span class="o">.</span><span class="n">HistogramPhaseUnwrapping</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
            <span class="n">params</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">Y</span>
            <span class="n">params</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">X</span>
            <span class="c1"># unwrapping_instance = cv2.phase_unwrapping.HistogramPhaseUnwrapping_create(params)</span>
            <span class="n">unwrapping_instance</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">phase_unwrapping</span><span class="o">.</span><span class="n">HistogramPhaseUnwrapping</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">fid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># todo: self.K[d] == 1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spatial phase unwrapping in 2D</span><span class="si">{</span><span class="s1">&#39; for each color indepently&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spatial phase unwrapping in 3D</span><span class="si">{</span><span class="s1">&#39; for each color indepently&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;ski&quot;</span>  <span class="c1"># todo: 3D SPU with OpenCV?</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">X</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">Y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="s2">&quot;cv2&quot;</span><span class="p">:</span>  <span class="c1"># OpenCV algorithm is usually faster, but can be much slower in noisy images</span>
                        <span class="c1"># dtype must be np.float32  # todo: test this</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vshape</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">phi</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                            <span class="n">ui</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span>
                            <span class="n">SNR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="n">ui</span>
                            <span class="n">upi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span> <span class="o">/</span> <span class="n">SNR</span>  <span class="c1"># local phase uncertainties</span>
                            <span class="n">upin</span> <span class="o">=</span> <span class="n">upi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># normalized local phase uncertainty</span>
                            <span class="n">uxi</span> <span class="o">=</span> <span class="n">upin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span>  <span class="c1"># local positional uncertainties</span>
                            <span class="n">ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                                <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">uxi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                            <span class="p">)</span>  <span class="c1"># global phase uncertainty (by inverse variance weighting of uxi)</span>
                            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ux</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># todo: which limit?</span>

                            <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrapping_instance</span><span class="o">.</span><span class="n">unwrapPhaseMap</span><span class="p">(</span>
                                <span class="n">phi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">mask</span>
                            <span class="p">)</span>  <span class="c1"># todo: test this</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrapping_instance</span><span class="o">.</span><span class="n">unwrapPhaseMap</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">])</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrapping_instance</span><span class="o">.</span><span class="n">getInverseReliabilityMap</span><span class="p">()</span>  <span class="c1"># todo: test this</span>
                            <span class="c1"># todo: res vs. rel</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Scikit-image algorithm is slower but delivers better results on edges</span>
                        <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">restoration</span><span class="o">.</span><span class="n">unwrap_phase</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">])</span>
                        <span class="c1"># todo: res</span>

            <span class="n">regmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">regmin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-=</span> <span class="n">regmin</span>

            <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">fid</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># np.nan  # unknown</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">uwr</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;unwrapping&quot;</span><span class="p">,</span> <span class="s2">&quot;registration residuals orders&quot;</span><span class="p">)(</span><span class="n">reg</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uwr</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;unwrapping&quot;</span><span class="p">,</span> <span class="s2">&quot;registration&quot;</span><span class="p">)(</span><span class="n">reg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">uwr</span>

<div class="viewcode-block" id="Fringes.unwrap"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.unwrap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span>
        <span class="n">phi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ski&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>  <span class="c1"># todo: use B for quality guidance</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unwrap phase maps spacially.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phi : np.ndarray</span>
<span class="sd">            Phase maps to unwrap spatially, stacked along the first dimension.</span>
<span class="sd">            It is reshaped to videoshape (frames &#39;T&#39;, height &#39;Y&#39;, width &#39;X&#39;, color channels &#39;C&#39;) before processing.</span>
<span class="sd">            The frames (along first dimension) as well the color channels (along last dimension)</span>
<span class="sd">            are unwrapped separately.</span>

<span class="sd">        mask : np.ndarray, optional</span>
<span class="sd">            Mask image with dtype &#39;np.uint8&#39; used when some pixels do not hold any phase information.</span>

<span class="sd">        func : str, optional</span>
<span class="sd">            Unwrapping function to use. The default is &#39;ski&#39;.</span>

<span class="sd">            - &#39;ski&#39;: `Scikit-image &lt;https://scikit-image.org/docs/stable/auto_examples/filters/plot_phase_unwrap.html&gt;`_</span>

<span class="sd">            - else: `OpenCV &lt;https://docs.opencv.org/4.7.0/df/d3a/group__phase__unwrapping.html&gt;`_</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unwrapped : np.ndarray</span>
<span class="sd">            Unwrapped phase map(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="s2">&quot;cv2&quot;</span><span class="p">:</span>  <span class="c1"># OpenCV unwrapping</span>
            <span class="c1"># params = cv2.phase_unwrapping_HistogramPhaseUnwrapping_Params()</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">phase_unwrapping</span><span class="o">.</span><span class="n">HistogramPhaseUnwrapping</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
            <span class="n">params</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">Y</span>
            <span class="n">params</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">X</span>
            <span class="c1"># unwrapping_instance = cv2.phase_unwrapping.HistogramPhaseUnwrapping_create(params)</span>
            <span class="n">unwrapping_instance</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">phase_unwrapping</span><span class="o">.</span><span class="n">HistogramPhaseUnwrapping</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">uwr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="s2">&quot;cv2&quot;</span><span class="p">:</span>  <span class="c1"># OpenCV algorithm is usually faster, but can be much slower in noisy images</span>
                    <span class="c1"># dtype must be np.float32  # todo: test this</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vshape</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">phi</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">uwr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrapping_instance</span><span class="o">.</span><span class="n">unwrapPhaseMap</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">mask</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">uwr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrapping_instance</span><span class="o">.</span><span class="n">unwrapPhaseMap</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">])</span>

                    <span class="c1"># # dtype of phasemust be np.uint8, dtype of shadow_mask np.uint8  # todo: test this</span>
                    <span class="c1"># reg[d, :, :, c] = unwrapping_instance.unwrapPhaseMap(phi[d, :, :, c], shadowMask=shadow_mask)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Scikit-image algorithm is slower but delivers better results on edges</span>
                    <span class="n">uwr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">restoration</span><span class="o">.</span><span class="n">unwrap_phase</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">uwr</span></div>

<div class="viewcode-block" id="Fringes.remap"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.remap">[docs]</a>    <span class="k">def</span> <span class="nf">remap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">fast</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Source activation heatmap.</span>

<span class="sd">        The decoded coordinates (having sub-pixel accuracy)</span>
<span class="sd">        are mapped from the camera grid</span>
<span class="sd">        to integer positions on the screen grid</span>
<span class="sd">        with weights from the modulation.</span>

<span class="sd">        This yields the source activation heatmap:</span>
<span class="sd">        a grid representing the screen (light source)</span>
<span class="sd">        with the pixel values being a relative measure</span>
<span class="sd">        of how much a screen (light source) pixel contributed</span>
<span class="sd">        to the exposure of the camera sensor.</span>

<span class="sd">        The dimensions of the screen are taken from the &#39;Fringes&#39; instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : np.ndarray</span>
<span class="sd">            Registration, i.e. the decoded screen coordinates as seen by the camera.</span>
<span class="sd">            It is reshaped to videoshape (frames &#39;T&#39;, height &#39;Y&#39;, width &#39;X&#39;, color channels &#39;C&#39;) before processing.</span>

<span class="sd">        B : np.ndarray, optional</span>
<span class="sd">            Modulation. Used for weighting.</span>
<span class="sd">            It is reshaped to videoshape (frames &#39;T&#39;, height &#39;Y&#39;, width &#39;X&#39;, color channels &#39;C&#39;) before processing.</span>
<span class="sd">            If &#39;B&#39; is not given, equal weights are used.</span>

<span class="sd">        dx : float, optional</span>
<span class="sd">            Magnification: Size of one camera pixel, projected onto the screen, in units of screen pixels.</span>
<span class="sd">            Default is one.</span>

<span class="sd">        p : int, optional</span>
<span class="sd">            Power parameter.</span>
<span class="sd">            Default is two.</span>

<span class="sd">        fast : bool</span>
<span class="sd">            If True, fast remapping is applied.</span>
<span class="sd">            Else, inverse distance weighted remapping is applied,</span>
<span class="sd">            which is more precise but also more time-consuming.</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        src : np.ndarray</span>
<span class="sd">            Source activation heatmap.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import fringes as frng</span>
<span class="sd">        &gt;&gt;&gt; f = frng.Fringes()</span>
<span class="sd">        &gt;&gt;&gt; I = f.encode()</span>

<span class="sd">        &gt;&gt;&gt; A, B, x = f.decode(I)</span>

<span class="sd">        &gt;&gt;&gt; src = f.remap(x, B)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">remap</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>  <span class="c1"># fixme: without param B  # todo</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">remap</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>
            <span class="c1"># return self._remap1(xi, B)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap3</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_remap1</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">B</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;&#39;xi&#39; and &#39;B&#39; have different width, height or number of color channels&quot;</span>

            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>

        <span class="c1"># todo</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xi</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
        <span class="c1"># assert all(np.all(np.round(np.max(xi[d])) &lt;= self.R[d] - 1 for d in range(self.D))), \</span>
        <span class="c1">#     f&quot;Coordinates contain values &gt; {self.R - 1}; decoding might be erroneous.&quot;</span>

        <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># self.axis == 1</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="n">xi</span><span class="p">))</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)),</span> <span class="n">C</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
            <span class="n">src</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">mx</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">src</span> <span class="o">/=</span> <span class="n">mx</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src</span>

    <span class="c1"># todo: weight with uncertainy?</span>
    <span class="k">def</span> <span class="nf">_remap3</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">)),</span>
        <span class="n">dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># inverse distance weighting using modified Shepard&#39;s method: https://en.wikipedia.org/wiki/Inverse_distance_weighting</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># trim B</span>
        <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&quot;&#39;xi&#39; and &#39;B&#39; have different width, height or number of color channels&quot;</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span> <span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>  <span class="c1"># n data points of dimension m</span>

        <span class="c1"># trim Xi</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
        <span class="c1"># todo</span>
        <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xi</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Coordinates contain values &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">; decoding might be erroneous.&quot;</span>
        <span class="k">if</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># xi = np.vstack((xi, np.zeros_like(xi)))</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># xi = np.vstack((np.zeros_like(xi), xi))</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># n data points of dimension m</span>

        <span class="c1"># mapping area of square with edge length &#39;dx&#39; to area of circle with radius &#39;R&#39;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">C</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
            <span class="n">kdtree</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">xi</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ys</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                        <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">distance_upper_bound</span><span class="o">=</span><span class="n">R</span>
                    <span class="p">)</span>  <span class="c1"># , workers=-1)  # todo: faster with more workers?</span>
                    <span class="c1"># todo: circular distance from indices</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
                            <span class="n">w</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span><span class="o">**</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                            <span class="n">w</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                            <span class="c1"># v = np.sum(B[i, c] * w)</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>

                        <span class="n">src</span><span class="p">[</span><span class="n">ys</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">src</span><span class="p">[</span><span class="n">ys</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">mx</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">src</span> <span class="o">/=</span> <span class="n">mx</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src</span>

    <span class="c1"># todo: add testing, or put into different module?</span>
    <span class="k">def</span> <span class="nf">_simulate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">I</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="c1"># magnification: float = 1,</span>
        <span class="n">PSF</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">system_gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.038</span><span class="p">,</span>
        <span class="n">dark_current</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.64</span> <span class="o">/</span> <span class="mf">0.038</span><span class="p">,</span>  <span class="c1"># [electrons]  # some cameras feature a dark current compensation</span>
        <span class="n">dark_noise</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">13.7</span><span class="p">,</span>  <span class="c1"># [electrons]</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">268664434431581513926327163960690138719</span><span class="p">,</span>  <span class="c1"># secrets.randbits(128)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate the acquisition, i.e. the transmission channel.</span>

<span class="sd">        This includes the modulation transfer function (computed from the imaging system&#39;s point spread function)</span>
<span class="sd">        and intensity noise added by the camera.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Fringe pattern sequence.</span>

<span class="sd">        PDF : float, optional</span>
<span class="sd">            Standard deviation of the Point Spread Function, in pixel units.</span>
<span class="sd">            The default is 3.</span>

<span class="sd">        system_gain : float, optional</span>
<span class="sd">            System gain of the digital camera.</span>
<span class="sd">            The default is 0.038.</span>

<span class="sd">        dark_current : float, optional</span>
<span class="sd">            Dark current of the digital camera, in unit electrons.</span>
<span class="sd">            The default is ~100.</span>

<span class="sd">        dark_noise : float, optional</span>
<span class="sd">            Dark noise of the digital camera, in units electrons.</span>
<span class="sd">            The default is 13.7</span>

<span class="sd">        seed : int, optional</span>
<span class="sd">            A seed to initialize the Random Number Generator.</span>
<span class="sd">            It makes the random numbers predictable.</span>
<span class="sd">            See `Seeding and Entropy &lt;http://www.example.com&gt;`_ for more information about seeding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : np.ndarray</span>
<span class="sd">            Simulated fringe pattern sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">I</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># # magnification</span>
        <span class="c1"># if magnification != 1:</span>
        <span class="c1">#     I = sp.ndimage.uniform_filter(I, size=magnification, mode=&quot;reflect&quot;, axes=(1, 2))</span>

        <span class="c1"># PSF (e.g. defocus)</span>
        <span class="k">if</span> <span class="n">PSF</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">PSF</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># random number generator</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># shot noise</span>
        <span class="n">shot</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">rng</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">I</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">system_gain</span><span class="p">)</span>

        <span class="c1"># dark noise</span>
        <span class="n">dark_current_y0</span> <span class="o">=</span> <span class="n">dark_current</span> <span class="o">*</span> <span class="n">system_gain</span>
        <span class="n">dark_noise_y0</span> <span class="o">=</span> <span class="n">dark_noise</span> <span class="o">*</span> <span class="n">system_gain</span>
        <span class="n">dark</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">dark_current_y0</span><span class="p">,</span> <span class="n">dark_noise_y0</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># spatial nonuniformity</span>
        <span class="n">SNU</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># todo</span>

        <span class="c1"># add noise</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">shot</span> <span class="o">+</span> <span class="n">dark</span> <span class="o">+</span> <span class="n">SNU</span>

        <span class="c1"># clip values</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">I</span><span class="p">)</span>

        <span class="c1"># quantization noise is added by converting to integer</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">I</span>

    <span class="k">def</span> <span class="nf">_trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change &#39;ndim&#39; to 2 and limit &#39;shape&#39;.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">a</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Kmax</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Dmax</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Kmax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Dmax</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Kmax</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="Fringes.errors"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.errors">[docs]</a>    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Error metrics.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dmed : np.ndarray</span>
<span class="sd">            Median of absolute distance between true and decoded coordinates.</span>

<span class="sd">        dcmed : np.ndarray</span>
<span class="sd">            Median of absolute circular distance between true and decoded coordinates.</span>

<span class="sd">        davg : np.ndarray</span>
<span class="sd">            Mean of absolute distance between true and decoded coordinates.</span>

<span class="sd">        dcavg : np.ndarray</span>
<span class="sd">            Mean of absolute circular distance between true and decoded coordinates.</span>

<span class="sd">        dmin : np.ndarray</span>
<span class="sd">            Mimimum of absolute distance between true and decoded coordinates.</span>

<span class="sd">        dcmin : np.ndarray</span>
<span class="sd">            Minimum of absolute circular distance between true and decoded coordinates.</span>

<span class="sd">        dmax : np.ndarray</span>
<span class="sd">            Maximum of absolute distance between true and decoded coordinates.</span>

<span class="sd">        dcmax : np.ndarray</span>
<span class="sd">            Maximum of absolute circular distance between true and decoded coordinates.</span>

<span class="sd">        std : np.ndarray</span>
<span class="sd">            Standard deviation of absolute distance between true and decoded coordinates.</span>

<span class="sd">        stdc : np.ndarray</span>
<span class="sd">            Standard deviation of absolute dircular distance between true and decoded coordinates.</span>

<span class="sd">        savg : np.ndarray</span>
<span class="sd">            Mean of success rate of phase unwrapping.</span>

<span class="sd">        smed : np.ndarray</span>
<span class="sd">            Median of success rate of phase unwrapping.</span>

<span class="sd">        smin : np.ndarray</span>
<span class="sd">            Minimum of success rate of phase unwrapping.</span>

<span class="sd">        smax : np.ndarray</span>
<span class="sd">            Maximum of success rate of phase unwrapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">simulate</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="n">xest</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">registration</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xest</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">dabs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">dmed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dabs</span><span class="p">)</span>
        <span class="n">davg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dabs</span><span class="p">)</span>
        <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dabs</span><span class="p">)</span>
        <span class="n">dmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dabs</span><span class="p">)</span>

        <span class="n">dc</span> <span class="o">=</span> <span class="n">circular_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">stdc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
        <span class="n">dcabs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
        <span class="n">dcavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dcabs</span><span class="p">)</span>
        <span class="n">dcmed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dcabs</span><span class="p">)</span>
        <span class="n">dcmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dcabs</span><span class="p">)</span>
        <span class="n">dcmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dcabs</span><span class="p">)</span>
        <span class="n">dcmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dcabs</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orders</span><span class="p">()</span>
        <span class="n">kest</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">orders</span>
        <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">kest</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">savg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">smed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">smin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">smax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

        <span class="n">errors</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
            <span class="s2">&quot;errors&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dmed dcmed davg dcavg dmin dcmin dmax dcmax std stdc savg smed smin smax&quot;</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">dmed</span><span class="p">,</span> <span class="n">dcmed</span><span class="p">,</span> <span class="n">davg</span><span class="p">,</span> <span class="n">dcavg</span><span class="p">,</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dcmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">dcmax</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">stdc</span><span class="p">,</span> <span class="n">savg</span><span class="p">,</span> <span class="n">smed</span><span class="p">,</span> <span class="n">smin</span><span class="p">,</span> <span class="n">smax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">errors</span></div>

<div class="viewcode-block" id="Fringes.MTF"><a class="viewcode-back" href="../../fringes.html#fringes.fringes.Fringes.MTF">[docs]</a>    <span class="k">def</span> <span class="nf">MTF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modulation Transfer Function.</span>

<span class="sd">        Returns the relative modulation at spatial frequencies &#39;v&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v: np.ndarray</span>
<span class="sd">            Spatial frequencies at which to determine the normalized modulation.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        B : np.ndarray</span>
<span class="sd">            Relative modulation, in the same shape as &#39;v&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If the attribute &#39;Bv&#39; of the Fringes instance is not None, the MTF is interpolated from previous measurements.\n</span>
<span class="sd">        - Else, if the attribute &#39;PSF&#39; of the Fringes instance is larger than zero, the MTF is computed from the optical transfer function of the optical system, i.e. as the magnitude of the Fourier-transformed &#39;Point Spread Function&#39; (PSF).\n</span>
<span class="sd">        - Else, it returns ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># interpolate from measurement</span>
            <span class="c1"># todo: test: unique + LUT</span>
            <span class="n">v_</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">vu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">MTF</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
                <span class="n">v_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bv</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span>
            <span class="p">)</span>  <span class="c1"># todo: ...and extrapolated at points outside the data range?</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">MTF</span><span class="p">(</span><span class="n">vu</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># interpolate from measured modulation values</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">vu</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">PSF</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># determine from PSF</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PSF</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># todo: fix</span>
            <span class="c1"># todo: what is smaller: dl or lv?</span>
            <span class="n">B</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># approximation of [Bothe2008]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">B</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Bv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modulation at spatial frequencies &#39;v&#39;.</span>

<span class="sd">        The modulation values are determined from a measurement.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Bv</span>

    <span class="nd">@Bv</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">Bv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Bv</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.Bv = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_Bv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">_B</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">vshape</span><span class="p">(</span><span class="n">_B</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">assert</span> <span class="n">T</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="n">_B</span> <span class="o">=</span> <span class="n">_B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>

        <span class="c1"># filter</span>
        <span class="n">_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">_B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># filter along color axis</span>
        <span class="c1"># _B = np.nanmedian(_B, axis=(2, 3))  # filter along spatial axes</span>
        <span class="n">_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">_B</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># filter along spatial axes</span>

        <span class="c1">#  normalize (only relative weights are important)</span>
        <span class="n">Bmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">_B</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="n">_B</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">_B</span> <span class="o">/=</span> <span class="n">Bmax</span>
        <span class="n">_B</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">_B</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">_Bv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">_B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Bv</span><span class="p">,</span> <span class="n">_Bv</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Bv</span> <span class="o">=</span> <span class="n">_B</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.Bv = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bv</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Coordinate system of the fringe patterns.</span>

<span class="sd">        The following values can be set:\n</span>
<span class="sd">        &#39;image&#39;:     The top left corner pixel of the grid is the origin and positive directions are right- resp. downwards.\n</span>
<span class="sd">        &#39;Cartesian&#39;: The center of grid is the origin and positive directions are right- resp. upwards.\n</span>
<span class="sd">        &#39;polar&#39;:     The center of grid is the origin and positive directions are clockwise resp. outwards.\n</span>
<span class="sd">        &#39;log-polar&#39;: The center of grid is the origin and positive directions are clockwise resp. outwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span>

    <span class="nd">@grid</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">_grid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">FTM</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t set &#39;grid&#39;: grid not in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">!=</span> <span class="n">_grid</span> <span class="ow">and</span> <span class="n">_grid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">_grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Angle of coordinate system&#39;s principal axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angle</span>

    <span class="nd">@angle</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_angle</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="mi">360</span><span class="p">))</span>  <span class="c1"># todo: +- 45</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angle</span> <span class="o">!=</span> <span class="n">_angle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_angle</span> <span class="o">=</span> <span class="n">_angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_angle</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of directions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span>

    <span class="nd">@D</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">D</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">_D</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Dmax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span> <span class="o">&gt;</span> <span class="n">_D</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_D</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="p">:]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span> <span class="o">&lt;</span> <span class="n">_D</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_D</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_D</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="n">_D</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="n">_D</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="n">_D</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Axis along which to shift if number of directions equals one.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span>

    <span class="nd">@axis</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">]:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">axis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">_axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">!=</span> <span class="n">_axis</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="n">_axis</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of frames.&quot;&quot;&quot;</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>  <span class="c1"># todo: fractional periods</span>
            <span class="n">T</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>  <span class="c1"># WDM along shifts</span>
                <span class="n">T</span> <span class="o">/=</span> <span class="mi">3</span>
            <span class="c1"># elif self.K &gt; self.D:  # WDM along sets todo</span>
            <span class="c1">#     a = np.sum(self._N, axis=1)</span>
            <span class="c1">#     b = np.max(a)</span>
            <span class="c1">#     c = np.ceil(b / 3)</span>
            <span class="c1">#     d = int(c)</span>
            <span class="c1">#</span>
            <span class="c1">#     a2 = np.sum(self._N, axis=0)</span>
            <span class="c1">#     b2 = np.max(a2)</span>
            <span class="c1">#     c2 = np.ceil(b2 / 2)</span>
            <span class="c1">#     d2 = int(c2)</span>
            <span class="c1">#</span>
            <span class="c1">#     if d &lt; d2:</span>
            <span class="c1">#         T = int(np.ceil(np.max(np.sum(self._N, axis=1)) / 3))</span>
            <span class="c1">#     else:  # use red and blue</span>
            <span class="c1">#         T = int(np.ceil(np.max(np.sum(self._N, axis=0)) / 2))</span>
            <span class="c1"># else:  # WDM along directions, use red and blue todo</span>
            <span class="c1">#     a = np.sum(self._N, axis=0)</span>
            <span class="c1">#     b = np.max(a)</span>
            <span class="c1">#     c = np.ceil(b / 2)</span>
            <span class="c1">#     d = int(c)</span>
            <span class="c1">#     T = int(np.ceil(np.max(np.sum(self._N, axis=1)) / 2))</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># use int() to ensure type is &quot;int&quot; instead of &quot;numpy.core.multiarray.scalar&quot;  # todo: necessary?</span>

    <span class="nd">@T</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># attention: params may change even if Tnew == Told</span>

        <span class="n">_T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tmax</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">_T</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># WDM + SDM todo: FTM?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t set &#39;T = 1&#39;: grid not in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># reset FDM before setting N</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># set N before WDM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">_T</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># WDM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># reset FDM before setting N</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># set N before WDM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># as long as enough shifts are there to compensate for nonlinearities,</span>
            <span class="c1"># it doesn&#39;t matter if we use more shifts or more sets</span>

            <span class="c1"># set boundaries</span>
            <span class="n">Nmin</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># minimum number of phase shifts for first set to de demodulated/decoded</span>
            <span class="n">N12</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># todo: N12 = Nmin == 3  # allow N to be in [1, 2] if K &gt;= 2</span>
            <span class="c1"># todo: N12 = 1 in self.N or 2 in self.N</span>
            <span class="n">Ngood</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># minimum number of phase shifts to obtain good results i.e. reliable results in practice</span>
            <span class="n">Kmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>  <span class="c1"># 2  # 3  # todo: which is better: 2 or 3?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># todo: T == 4 -&gt; no mod</span>
            <span class="c1">#  T == 5 -&gt; FDM if _T &gt;= Nmin?</span>

            <span class="c1"># try D == 2  # todo: mux</span>
            <span class="k">if</span> <span class="n">_T</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Nmin</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="c1"># try to keep hues</span>
            <span class="k">if</span> <span class="n">_T</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="n">Nmin</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="n">Nmin</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">_T</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_T</span> <span class="o">//=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span>

            <span class="c1"># try K = Kmax</span>
            <span class="k">if</span> <span class="n">N12</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">-</span> <span class="p">(</span><span class="n">Nmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Nmin - 1 = 2; i.e. 2 more for first set</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="n">Nmin</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">Kmax</span><span class="p">)</span>

            <span class="c1"># ensure UMR &gt;= R</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isambiguous</span><span class="p">:</span>
                <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># try N &gt;= Ngood &gt;= Nmin</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">Navg</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Navg</span> <span class="o">&lt;</span> <span class="n">Nmin</span><span class="p">:</span>  <span class="c1"># use N12</span>
                <span class="n">N</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nmin</span>
                <span class="n">Nbase</span> <span class="o">=</span> <span class="p">(</span><span class="n">_T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="n">Nmin</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># attention: if K == 1 -&gt; D == 1</span>
                <span class="n">N</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Nbase</span>
                <span class="n">dT</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dT</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
                    <span class="n">N</span><span class="p">[:,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">dT</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">Navg</span>
                <span class="n">dT</span> <span class="o">=</span> <span class="n">_T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dT</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
                    <span class="n">N</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">dT</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">dT</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
                        <span class="n">N</span><span class="p">[:</span><span class="n">d</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Y</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Height of fringe patterns.</span>
<span class="sd">        [Y] = px.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span>

    <span class="nd">@Y</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">Y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">_Y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ymax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Pmax</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span> <span class="o">!=</span> <span class="n">_Y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span> <span class="o">=</span> <span class="n">_Y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_Y</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Width of fringe patterns.</span>
<span class="sd">        [X] = px.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span>

    <span class="nd">@X</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">_X</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Pmax</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">!=</span> <span class="n">_X</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">=</span> <span class="n">_X</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_X</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of color channels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ismono</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">P</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of pixels per color channel and frame.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factor for extending the coding range &#39;L&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span>

    <span class="nd">@alpha</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_alpha</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alphamax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">!=</span> <span class="n">_alpha</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">_alpha</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lengths of fringe patterns for each direction.</span>
<span class="sd">        [R] = px.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">R</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length to be encoded.</span>
<span class="sd">        [L] = px.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">UMR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unambiguous measurement range.</span>

<span class="sd">        The coding is only unique within the interval [0, UMR); after that it repeats itself.</span>

<span class="sd">        The UMR is derived from l and v:\n</span>
<span class="sd">        - If l  , UMR = lcm(li) with lcm being the least common multiple.\n</span>
<span class="sd">        - Else, if v  , UMR = L/ gcd(vi) with gcd being the greatest common divisor.\n</span>
<span class="sd">        - Else, if l  v  , lcm resp. gcd are extended to rational numbers.\n</span>
<span class="sd">        - Else, if l  v   \ , l and v are approximated by rational numbers with a fixed length of decimal digits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># cache</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span>  <span class="c1"># todo: resetting cache doesn&#39;t work for some reasons...</span>

        <span class="c1"># precision = np.finfo(&quot;float64&quot;).precision - 1</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="n">UMR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>  <span class="c1"># .copy()</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span>  <span class="c1"># here, in TPU twice the combinations have to be tried</span>
                <span class="c1"># todo: test if valid</span>
                <span class="n">l</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>
                <span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>  <span class="c1"># equivalently: np.inf in l</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># one since we can only control discrete pixels</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">):</span>  <span class="c1"># all l are integers</span>
                <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">):</span>  <span class="c1"># all v are integers</span>
                <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="n">precision</span><span class="p">)):</span>
                <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>  <span class="c1"># all l are approximately integers</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="n">precision</span><span class="p">)):</span>
                <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">v</span><span class="p">)])</span>  <span class="c1"># all v are approximately integers</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># l and v both are not integers, not even approximately</span>
                <span class="n">lcopy</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># mutual factorial test for integers i.e. mutual divisibility test</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">**-</span><span class="n">precision</span><span class="p">:</span>
                            <span class="n">lcopy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">**-</span><span class="n">precision</span><span class="p">:</span>
                            <span class="n">lcopy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">lcopy</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># estimate whether elements are rational or irrational</span>
                <span class="n">decimals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>  <span class="c1"># -1: dot</span>
                <span class="n">Dl</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
                <span class="n">decimals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>  <span class="c1"># -1: dot</span>
                <span class="n">Dv</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">Dl</span><span class="p">,</span> <span class="n">Dv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">precision</span><span class="p">:</span>  <span class="c1"># rational numbers without integers (i.e. not covered by isclose(atol))</span>
                    <span class="c1"># extend lcm/gcd to rational numbers</span>

                    <span class="k">if</span> <span class="n">Dl</span> <span class="o">&lt;=</span> <span class="n">Dv</span><span class="p">:</span>
                        <span class="n">ls</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="n">Dl</span>  <span class="c1"># wavelengths scaled</span>
                        <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">])</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="n">Dl</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Extended lcm to rational numbers.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vs</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">Dv</span><span class="p">)</span>  <span class="c1"># wavelengths scaled</span>
                        <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">Dv</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Extended gcd to rational numbers.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># irrational numbers or rational numbers with more digits than &quot;precision&quot;</span>
                    <span class="c1"># round and extend lcm to rational numbers</span>
                    <span class="n">ls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="n">precision</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint64&quot;</span><span class="p">)</span>
                    <span class="n">UMR</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="n">precision</span>

        <span class="c1"># self._UMR = float(np.min(UMR))  # cast type frm &quot;numpy.core.multiarray.scalar&quot; to &quot;int&quot; or &quot;float&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span> <span class="o">=</span> <span class="n">UMR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.UMR = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">UMR</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">):</span>  <span class="c1"># self._isambiguous:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;UMR &lt; R. Unwrapping will not be spatially independent and only yield a relative phase map.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Coding efficiency.&quot;&quot;&quot;</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">UMR</span>
        <span class="n">eta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">UMR</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">eta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">M</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of averaged intensity samples.&quot;&quot;&quot;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># todo: M = M[None, None, :]</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>  <span class="c1"># convert Numpy float64 to Python float  # todo: fix M.max()</span>

    <span class="nd">@M</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">M</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_M</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Mmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">!=</span> <span class="n">_M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># fractional part only</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="nb">int</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">_M</span> <span class="o">%</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_M</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># integer part only</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">_M</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># integer and fractional part</span>
                <span class="n">h_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">_M</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">h_fract</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="nb">int</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">_M</span> <span class="o">%</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h_int</span><span class="p">,</span> <span class="n">h_fract</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of hues.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@H</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">_H</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Hmax</span><span class="p">))</span>

        <span class="c1"># if self.WDM:</span>
        <span class="c1">#     self.logger.error(&quot;Couldn&#39;t set &#39;H&#39;: WDM is active.&quot;)</span>
        <span class="c1">#     return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">!=</span> <span class="n">_H</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span> <span class="o">*</span> <span class="n">_H</span>
            <span class="k">elif</span> <span class="n">_H</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span>
            <span class="k">elif</span> <span class="n">_H</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="s2">&quot;rb&quot;</span>  <span class="c1"># todo</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="s2">&quot;rgb&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_H</span> <span class="o">//</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">[:</span><span class="n">_H</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hues i.e. colors of fringe patterns.</span>

<span class="sd">        Possible values are any sequence of RGB color triples within the interval [0, 255].</span>
<span class="sd">        However, black (0, 0, 0) is not allowed.</span>

<span class="sd">        The hue values can also be set by assigning any combination of the following characters as a string:\n</span>
<span class="sd">        - &#39;r&#39;: red \n</span>
<span class="sd">        - &#39;g&#39;: green\n</span>
<span class="sd">        - &#39;b&#39;: blue\n</span>
<span class="sd">        - &#39;c&#39;: cyan\n</span>
<span class="sd">        - &#39;m&#39;: magenta\n</span>
<span class="sd">        - &#39;y&#39;: yellow\n</span>
<span class="sd">        - &#39;w&#39;: white\n</span>

<span class="sd">        Before decoding, repeating hues will be fused by averaging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span>

    <span class="nd">@h</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">LUT</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span>
                <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span>
                <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span>
                <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">LUT</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="n">LUT</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">h</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">h</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;h&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="c1"># make array, clip first and then cast to dtype to avoid integer under-/overflow</span>
        <span class="n">_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_h</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c1"># empty array</span>
            <span class="k">return</span>

        <span class="c1"># trim: change shape to (H, 3) or limit shape</span>
        <span class="k">if</span> <span class="n">_h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">_h</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">_h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">_h</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">_h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="n">_h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">_h</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="n">_h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_h</span> <span class="o">=</span> <span class="n">_h</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Hmax</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_h</span> <span class="o">=</span> <span class="n">_h</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Hmax</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">_h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># C-axis must equal 3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;h&#39;: Only 2 instead of 3 color channels provided.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t set &#39;h&#39;: Black color is not allowed.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ismono</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;h&#39;: &#39;WDM&#39; is active, but not all hues are monochromatic.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="p">,</span> <span class="n">_h</span><span class="p">):</span>
            <span class="n">Hold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_h</span> <span class="o">=</span> <span class="n">_h</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self._h = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Hold</span> <span class="o">!=</span> <span class="n">_h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.H = </span><span class="si">{</span><span class="n">_h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># computed upon call</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># computed upon call</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">TDM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Temporal division multiplexing.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SDM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spatial division multiplexing.</span>

<span class="sd">        The directions D are multiplexed, resulting in a crossed fringe pattern.</span>
<span class="sd">        The amplitude B is halved.</span>
<span class="sd">        It can only be activated if we have two directions, i.e. D  2.</span>
<span class="sd">        The number of frames T is reduced by the factor 2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SDM</span>

    <span class="nd">@SDM</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">SDM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SDM</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">_SDM</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">SDM</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_SDM</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">_SDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t set &#39;SDM&#39;: Pointless as only one dimension exist.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">_SDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t set &#39;SDM&#39;: grid not in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
                <span class="n">_SDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;SDM&#39;: FDM is active.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SDM</span> <span class="o">!=</span> <span class="n">_SDM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_SDM</span> <span class="o">=</span> <span class="n">_SDM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_SDM</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># computed upon call</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">WDM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wavelength division multiplexing.</span>

<span class="sd">        The shifts are multiplexed into the color channel, resulting in an RGB fringe pattern.</span>
<span class="sd">        It can only be activated if all shifts equal 3, i.e. N  3.</span>
<span class="sd">        The number of frames T is reduced by the factor 3.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WDM</span>

    <span class="nd">@WDM</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">WDM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">WDM</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">_WDM</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">WDM</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_WDM</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">_WDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;WDM&#39;: At least one Shift != 3.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ismono</span><span class="p">:</span>
                <span class="n">_WDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;WDM&#39;: Not all hues are monochromatic.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>  <span class="c1"># todo: remove this, already covered by N</span>
                <span class="n">_WDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;WDM&#39;: FDM is active.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WDM</span> <span class="o">!=</span> <span class="n">_WDM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_WDM</span> <span class="o">=</span> <span class="n">_WDM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_WDM</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># computed upon call</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">FDM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Frequency division multiplexing.</span>

<span class="sd">        The directions D and the sets K are multiplexed, resulting in a crossed fringe pattern if D  2.</span>
<span class="sd">        It can only be activated if D  K &gt; 1 i.e. D * K &gt; 1.</span>
<span class="sd">        The amplitude B is reduced by the factor D * K.</span>
<span class="sd">        Usually f equals 1 and is essentially only changed if frequency division multiplexing (FDM) is activated:</span>
<span class="sd">        Each set per direction receives an individual temporal frequency f, which is used in temporal demodulation to distinguish the individual sets.</span>
<span class="sd">        A minimal number of shifts Nmin   2 * fmax + 1  is required to satisfy the sampling theorem and N is updated automatically if necessary.</span>
<span class="sd">        If one wants a static pattern, i.e. one that remains congruent when shifted, set static to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FDM</span>

    <span class="nd">@FDM</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">FDM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FDM</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">_FDM</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">FDM</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_FDM</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_FDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t set &#39;FDM&#39;: Dimensions * Sets = 1, so nothing to multiplex.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span><span class="p">:</span>
                <span class="n">_FDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;FDM&#39;: SDM is active.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span><span class="p">:</span>  <span class="c1"># todo: remove, already covered by N</span>
                <span class="n">_FDM</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;FDM&#39;: WDM is active.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FDM</span> <span class="o">!=</span> <span class="n">_FDM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_FDM</span> <span class="o">=</span> <span class="n">_FDM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_FDM</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># self.K = self._K</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span>

            <span class="c1"># keep maximum possible visibility constant</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag for creating static fringes (so they remain congruent when shifted).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static</span>

    <span class="nd">@static</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">_static</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">static</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static</span> <span class="o">!=</span> <span class="n">_static</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static</span> <span class="o">=</span> <span class="n">_static</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_static</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of sets (number of fringe patterns with different spatial frequencies).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span>

    <span class="nd">@K</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># todo: different K for each D: use array of arrays</span>
        <span class="c1"># a = np.ones(2)</span>
        <span class="c1"># b = np.ones(5)</span>
        <span class="c1"># c = np.array([a, b])</span>

        <span class="n">Kmax</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Nmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Kmax</span>  <span class="c1"># todo: check if necessary</span>
        <span class="n">_K</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">Kmax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">&gt;</span> <span class="n">_K</span><span class="p">:</span>  <span class="c1"># remove elements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">=</span> <span class="n">_K</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_D</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">&lt;</span> <span class="n">_K</span><span class="p">:</span>  <span class="c1"># add elements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">=</span> <span class="n">_K</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">_K</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>  <span class="c1"># don&#39;t append N from defaults, this might be in conflict with WDM!</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">_K</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Nmin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimum number of shifts to (uniformly) sample temporal frequencies.</span>

<span class="sd">        Per direction at least one set with N  3 is necessary</span>
<span class="sd">        to solve for the three unknowns brightness A, modulation B and coordinate xi.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="n">Nmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># sampling theorem</span>
            <span class="c1"># todo: 2 * D * K + 1 -&gt; fractional periods if static</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Nmin</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 3</span>
        <span class="k">return</span> <span class="n">Nmin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of phase shifts.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># sets in directions are identical</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 1D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>  <span class="c1"># 2D</span>
        <span class="k">return</span> <span class="n">N</span>

    <span class="nd">@N</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Nmax</span><span class="p">)</span>  <span class="c1"># make array, cast to dtype, clip</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_N</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c1"># empty array</span>
            <span class="k">return</span>

        <span class="n">_N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">(</span><span class="n">_N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">_N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># any</span>
            <span class="k">pass</span>  <span class="c1"># FTM</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_N</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>  <span class="c1"># np.argmin(_N[d])</span>
                    <span class="n">_N</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">WDM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">_N</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t set &#39;N&#39;: At least one Shift != 3.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">_N</span> <span class="o">==</span> <span class="n">_N</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># _N = np.tile(self.Nmin, _N.shape)</span>
            <span class="n">_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">_N</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">_N</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span> <span class="n">_N</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">_N</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self._N = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lmin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimum resolvable wavelength.</span>
<span class="sd">        [lmin] = px.&quot;&quot;&quot;</span>
        <span class="n">fmax</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">min</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lmin</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">)</span>  <span class="c1"># don&#39;t use self.fmax, else circular loop</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">fmax</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lmin</span>

    <span class="nd">@lmin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lmin</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_lmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lminmin</span><span class="p">,</span> <span class="n">lmin</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lmin</span> <span class="o">!=</span> <span class="n">_lmin</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lmin</span> <span class="o">=</span> <span class="n">_lmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lmin</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># computed upon call</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span>  <span class="c1"># l triggers v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lopt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optimal wavelength for minimal decoding uncertainty.</span>
<span class="sd">        [lopt] = px.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vopt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wavelengths of fringe periods.</span>
<span class="sd">        [l] = px.</span>

<span class="sd">        When L changes, v is kept constant and only l is changed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span>

    <span class="nd">@l</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span>
                <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;optimal&quot;</span><span class="p">:</span>
                <span class="n">lmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">))</span>
                <span class="n">lmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                        <span class="nb">max</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">lmin</span><span class="p">,</span>  <span class="c1"># todo: only if B differ slightly</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">,</span>
                            <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lopt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">lmin</span> <span class="o">==</span> <span class="n">lmax</span> <span class="ow">and</span> <span class="n">lmax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                    <span class="n">lmax</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">lmax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sympy</span><span class="o">.</span><span class="n">isprime</span><span class="p">(</span><span class="n">lmax</span><span class="p">):</span>
                    <span class="n">lmax</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ntheory</span><span class="o">.</span><span class="n">generate</span><span class="o">.</span><span class="n">nextprime</span><span class="p">(</span><span class="n">lmax</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># ensures lcm(a, lmax) &gt;= L for all a &gt;= lmin</span>

                <span class="n">n</span> <span class="o">=</span> <span class="n">lmax</span> <span class="o">-</span> <span class="n">lmin</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="n">l_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lmin</span><span class="p">])</span>
                <span class="n">l_max</span> <span class="o">=</span> <span class="n">lmin</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">lcm</span> <span class="o">=</span> <span class="n">l_</span>
                <span class="k">while</span> <span class="n">lcm</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                    <span class="n">lcm_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="n">l_max</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">lcm_new</span> <span class="o">&gt;</span> <span class="n">lcm</span><span class="p">:</span>
                        <span class="n">l_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_</span><span class="p">,</span> <span class="n">l_max</span><span class="p">)</span>
                        <span class="n">lcm</span> <span class="o">=</span> <span class="n">lcm_new</span>
                    <span class="n">l_max</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">K</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

                <span class="n">C</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># number of unique combinations</span>
                <span class="n">combos</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">K</span><span class="p">)</span>

                <span class="c1"># B = int(np.ceil(np.log2(lmax - 1) / 8)) * 8  # number of bits required to store integers up to lmax</span>
                <span class="c1"># combos = np.fromiter(combos, np.dtype((f&quot;uint{B}&quot;, K)), C)</span>

                <span class="n">kroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">K</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="o">&lt;=</span> <span class="n">kroot</span><span class="p">:</span>
                    <span class="n">lcombos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">combos</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">kroot</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lcombos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">combos</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">])</span>

                <span class="c1"># lcombos = filter(lcombos, K, self.L, lmin)</span>

                <span class="c1"># idx = np.argmax(np.sum(1 / lcombos**2, axis=1))</span>
                <span class="c1"># l = lcombos[idx]</span>

                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">lcombos</span>
                <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MTF</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">var</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">lcombos</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">B</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># todo: D, M</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">l</span> <span class="o">=</span> <span class="n">lcombos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="n">K</span><span class="p">,</span> <span class="n">lmin</span><span class="p">),</span> <span class="n">l</span><span class="p">))</span>

                <span class="c1"># while lmax &lt; self.L and np.gcd(lmin, lmax) != 1:</span>
                <span class="c1">#     lmax += 1  # maximum number of iterations? = min(next prime after lmax - lmax, max(0, L - lmax, ))</span>
                <span class="c1"># l = np.array([lmin] * (self.K - 1) + [lmax])</span>

                <span class="c1"># vmax = int(max(1 if self.K == 1 else 2, self.vmax))  # todo: ripples from int()</span>
                <span class="c1"># v = np.array([vmax] * (self.K - 1) + [vmax - 1])  # two consecutive numbers are always coprime</span>
                <span class="c1"># lv = self.L / v</span>
                <span class="c1"># lv = np.maximum(self._lmin, np.minimum(lv, self.L))</span>
                <span class="c1">#</span>
                <span class="c1"># idx = np.argmax((np.sum(1 / (l ** 2), axis=0), np.sum(1 / (lv ** 2), axis=0)))</span>
                <span class="c1"># l = l if idx == 0 else lv</span>
                <span class="c1"># print(&quot;l&quot; if idx == 0 else &quot;v&quot;)</span>
            <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;close&quot;</span><span class="p">:</span>
                <span class="n">lmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">lmin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;small&quot;</span><span class="p">:</span>
                <span class="n">lmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">))</span>
                <span class="n">lmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)))</span>  <span class="c1"># wavelengths are around kth root of self.L</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">lmax</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">lmax</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">lmax</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># kth root was even</span>
                            <span class="n">lmax</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="n">ith</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">3</span>
                            <span class="n">lmax</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ntheory</span><span class="o">.</span><span class="n">generate</span><span class="o">.</span><span class="n">nextprime</span><span class="p">(</span><span class="n">lmax</span><span class="p">,</span> <span class="n">ith</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lmin</span> <span class="o">&gt;</span> <span class="n">lmax</span> <span class="ow">or</span> <span class="n">lmax</span> <span class="o">-</span> <span class="n">lmin</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">lmin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="n">lmin</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">lmax</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)))</span>
                    <span class="p">)</span>  <span class="c1"># max in outer condition ensures lmax &gt;= lmin even if L &lt; lmin</span>
                    <span class="k">if</span> <span class="n">lmin</span> <span class="o">==</span> <span class="n">lmax</span> <span class="ow">and</span> <span class="n">lmax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                        <span class="n">lmax</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># ensures lmin and lmax differ so that lcm(l) &gt;= L</span>

                    <span class="n">n</span> <span class="o">=</span> <span class="n">lmax</span> <span class="o">-</span> <span class="n">lmin</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">K</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># ensures K &lt;= n</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># number of unique combinations</span>
                    <span class="n">combos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">c</span>
                            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">K</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">combos</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">combos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="n">K</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;exponential&quot;</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to be safe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_l</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>  <span class="c1"># kept for backwards compatibility with fringes-GUI</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vmax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum resolvable spatial frequency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vopt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optimal spatial frequency for minimal decoding uncertainty.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># interpolate from measurement</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MTF</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]]</span>
            <span class="n">var</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">/</span> <span class="n">N</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">B</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># todo: D, M</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">vopt</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">PSF</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># determine from PSF</span>
            <span class="n">vopt_</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">PSF</span><span class="p">)</span>
            <span class="n">lopt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">vopt_</span>
            <span class="n">vopt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">lopt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vopt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># approximation [Bothe2008]</span>

        <span class="k">return</span> <span class="n">vopt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spatial frequencies (number of periods/fringes across maximum coding length).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># sets in directions are identical</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 1D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span>  <span class="c1"># 2D</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@v</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;optimal&quot;</span><span class="p">:</span>
                <span class="c1"># |{v}| = 2</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vopt</span><span class="p">))</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vmax</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">vmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># two consecutive numbers are always coprime</span>

                <span class="c1"># # # |{v}| = K</span>
                <span class="c1"># vmax = int(max(self.K, self.vopt))</span>
                <span class="c1"># v = vmax - np.arange(self.K)</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;exponential&quot;</span><span class="p">:</span>
                <span class="c1"># K = int(np.ceil(np.log2(self.vmax))) + 1  # + 1: 2 ** 0 = 1</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">)</span>  <span class="c1"># make array, cast to dtype, clip</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_v</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c1"># empty array</span>
            <span class="k">return</span>

        <span class="n">_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">_v</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">_v</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span>
                <span class="p">):</span>  <span class="c1"># todo: allow coprimes?!</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">ith</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
                    <span class="n">pmax</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ntheory</span><span class="o">.</span><span class="n">generate</span><span class="o">.</span><span class="n">nextprime</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ith</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">ntheory</span><span class="o">.</span><span class="n">generate</span><span class="o">.</span><span class="n">primerange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">pmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))[:</span><span class="n">ith</span><span class="p">]</span>  <span class="c1"># primes</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))]</span>  <span class="c1"># resort primes</span>
                    <span class="n">_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># resort primes</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Periods were not coprime. &quot;</span> <span class="sa">f</span><span class="s2">&quot;Changing values to </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">_v</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     vmax = (self._Nmax - 1) / 2 &gt; _v</span>
            <span class="c1">#     _v = np.minimum(_v, vmax)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">,</span> <span class="n">_v</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_v</span> <span class="o">=</span> <span class="n">_v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.v = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.l = </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_UMR</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>
            <span class="n">UMR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">UMR</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum temporal frequency (maximum number of periods to shift over).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Temporal frequency (number of periods to shift over).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># sets in directions are identical</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 1D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>  <span class="c1"># 2D</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="nd">@f</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">fmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmax</span><span class="p">)</span>  <span class="c1"># make array, cast to dtype, clip</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_f</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c1"># empty array</span>
            <span class="k">return</span>

        <span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim</span><span class="p">(</span><span class="n">_f</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_f</span><span class="p">[:</span><span class="n">D</span><span class="p">,</span> <span class="p">:</span><span class="n">K</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[:</span><span class="n">D</span><span class="p">,</span> <span class="p">:</span><span class="n">K</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># _f = np.ones(_f.shape)</span>
            <span class="n">_f</span><span class="p">[:</span><span class="n">D</span><span class="p">,</span> <span class="p">:</span><span class="n">K</span><span class="p">][</span><span class="n">_f</span><span class="p">[:</span><span class="n">D</span><span class="p">,</span> <span class="p">:</span><span class="n">K</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[:</span><span class="n">D</span><span class="p">,</span> <span class="p">:</span><span class="n">K</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
                <span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_v</span>  <span class="c1"># periods to shift over = one full revolution</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">_f</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_f</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">_f</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="n">_f</span><span class="o">.</span><span class="n">size</span>
                <span class="p">):</span>  <span class="c1"># assure _f are int and absolute values of _f differ</span>
                    <span class="n">_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">))</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_f</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">_f</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">_f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self._f = </span><span class="si">{</span><span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>  <span class="c1"># todo: remove if fractional periods is implemented, log warning</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">o</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Phase offset within interval (-2pi, +2pi).</span>

<span class="sd">        It can be used to e.g. let the fringe patterns start (at the origin) with a gray value of zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_o</span>

    <span class="nd">@o</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">o</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_o</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_o</span> <span class="o">!=</span> <span class="n">_o</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_o</span> <span class="o">=</span> <span class="n">_o</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self._o = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="si">}</span><span class="s2"> PI&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ismono</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if all hues are monochromatic, i.e. RGB values are identical for each hue.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_isambiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if unambiguous measument range is larger than the screen length.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">UMR</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mode for encoding and decoding.</span>

<span class="sd">        The following values can be set:\n</span>
<span class="sd">        - &#39;fast&#39;\n</span>
<span class="sd">        - &#39;precise&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span>

    <span class="nd">@mode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">_mode</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">!=</span> <span class="n">_mode</span> <span class="ow">and</span> <span class="n">_mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">_mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag for shifting fringes in reverse direction.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reverse</span>

    <span class="nd">@reverse</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">_reverse</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">reverse</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reverse</span> <span class="o">!=</span> <span class="n">_reverse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reverse</span> <span class="o">=</span> <span class="n">_reverse</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_reverse</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self._f = </span><span class="si">{</span><span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">verbose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag for additionally returning intermediate and verbose results:\n</span>
<span class="sd">        - phase map\n</span>
<span class="sd">        - residuals\n</span>
<span class="sd">        - fringe orders\n</span>
<span class="sd">        - visibility\n</span>
<span class="sd">        - exposure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>

    <span class="nd">@verbose</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">verbose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">_verbose</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">!=</span> <span class="n">_verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">_verbose</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">FTM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the Fourier-transform method deployed.&quot;&quot;&quot;</span>
        <span class="c1"># todo: allow H &gt; 1 and use decolorizing, then conduct FTM for each color</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grids</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">PU</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Phase unwrapping method.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FTM</span><span class="p">:</span>
            <span class="c1"># todo: v &gt;&gt; 1, i.e. l ~ 8</span>
            <span class="n">PU</span> <span class="o">=</span> <span class="s2">&quot;FTM&quot;</span>  <span class="c1"># Fourier-transform method</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">PU</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isambiguous</span><span class="p">:</span>
            <span class="n">PU</span> <span class="o">=</span> <span class="s2">&quot;spatial&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">PU</span> <span class="o">=</span> <span class="s2">&quot;temporal&quot;</span>

        <span class="k">return</span> <span class="n">PU</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma correction factor used to compensate the display response curve.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span>

    <span class="nd">@gamma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_gamma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gammamax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span> <span class="o">!=</span> <span class="n">_gamma</span> <span class="ow">and</span> <span class="n">_gamma</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span> <span class="o">=</span> <span class="n">_gamma</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape of fringe pattern sequence in video shape (frames, height, with, color channels).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of pixels of fringe pattern sequence (frames * height * width * color channels).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>  <span class="c1"># using uint64 prevents integer overflow</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total bytes consumed by fringe pattern sequence.</span>

<span class="sd">        Does not include memory consumed by non-element attributes of the array object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Data type.</span>

<span class="sd">        The following values can be set:\n</span>
<span class="sd">        - &#39;bool&#39;\n</span>
<span class="sd">        - &#39;uint8&#39;\n</span>
<span class="sd">        - &#39;uint16&#39;\n</span>
<span class="sd">        - &#39;float32&#39;\n</span>
<span class="sd">        - &#39;float64&#39;\n</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>  <span class="c1"># this is a hotfix for setting _dtype directly as a str in init</span>

    <span class="nd">@dtype</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">|</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">!=</span> <span class="n">_dtype</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">_dtype</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtypes</span><span class="p">:</span>
            <span class="n">Imaxold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">_dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.A = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.B = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Imax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum gray value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Amin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimum bias.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vmax</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Amax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum bias.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Amin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bias.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>

    <span class="nd">@A</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_A</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Amin</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Amax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">!=</span> <span class="n">_A</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">_A</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Bmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum amplitude.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vmax</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Amplitude.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>

    <span class="nd">@B</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_B</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bmax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">!=</span> <span class="n">_B</span><span class="p">:</span>  <span class="c1"># and _B != 0:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">_B</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">betamax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum relative bias (exposure).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Relative bias (exposure), i.e. relative mean intensity  [0, 1].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span>

    <span class="nd">@beta</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">_beta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">betamax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">!=</span> <span class="n">_beta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">=</span> <span class="n">_beta</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Vmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum visibility.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDM</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SDM</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fringe visibility (fringe contrast)  [0, 1].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_V</span>

    <span class="nd">@V</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_V</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vmax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">!=</span> <span class="n">_V</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">=</span> <span class="n">_V</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">umin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Standard deviation of minimum uncertainty for measurement to be valid.</span>
<span class="sd">        [umin] = px.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_umin</span>

    <span class="nd">@umin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">umin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">umin</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_umin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">umin</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># L / 2 due to circular distribution</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_umin</span> <span class="o">!=</span> <span class="n">_umin</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_umin</span> <span class="o">=</span> <span class="n">_umin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_umin</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def r(self) -&gt; int:</span>
    <span class="c1">#     &quot;&quot;&quot;Number of quantization bits.&quot;&quot;&quot;</span>
    <span class="c1">#     return 1 if self.dtype.kind in &quot;b&quot; else np.iinfo(</span>
    <span class="c1">#         self.dtype).bits if self.dtype.kind in &quot;ui&quot; else 10 ** np.finfo(self.dtype).precision</span>

    <span class="c1"># @property</span>
    <span class="c1"># def Q(self) -&gt; float:</span>
    <span class="c1">#     &quot;&quot;&quot;Number of quantization levels.&quot;&quot;&quot;</span>
    <span class="c1">#     return 2 ** self.r</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Quantization step size.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;uib&quot;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">resolution</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quant</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Quantization noise (standard deviation).</span>
<span class="sd">        [quant] = DN.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>  <span class="c1"># convert Numpy float64 to Python float</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dark</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dark noise of digital camera (standard deviation).</span>
<span class="sd">        [dark] = electrons.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dark</span>

    <span class="nd">@dark</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dark</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_dark</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dark</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imax</span><span class="p">)))</span>

        <span class="c1"># _dark = max(_dark, 0.49)  # todo: temporal noise is dominated by quantization noise -&gt;</span>

        <span class="n">_dark</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_dark</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">)</span>  <span class="c1"># correct for quantization noise contained in dark noise measurement</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dark</span> <span class="o">!=</span> <span class="n">_dark</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dark</span> <span class="o">=</span> <span class="n">_dark</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dark</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shot noise of digital camera (standard deviation).</span>
<span class="sd">        [shot] = DN.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># average intensity is bias</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overall system gain of digital camera.</span>
<span class="sd">        [gain] = DN / electrons.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gain</span>

    <span class="nd">@gain</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_gain</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gain</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gain</span> <span class="o">!=</span> <span class="n">_gain</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gain</span> <span class="o">=</span> <span class="n">_gain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_gain</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">magnification</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Magnification, i.e. ratio of camera pixels to screen pixels.</span>

<span class="sd">        This many camera pixels look at one screen pixel.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magnification</span>

    <span class="nd">@magnification</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">magnification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magnification</span><span class="p">):</span>
        <span class="n">_magnification</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">magnification</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magnification</span> <span class="o">!=</span> <span class="n">_magnification</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_magnification</span> <span class="o">=</span> <span class="n">_magnification</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_magnification</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">PSF</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Standard deviation of Point Spread Function for defocus.</span>
<span class="sd">        [PSF] = px.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PSF</span>

    <span class="nd">@PSF</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">PSF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PSF</span><span class="p">):</span>
        <span class="n">_PSF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PSF</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PSF</span> <span class="o">!=</span> <span class="n">_PSF</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_PSF</span> <span class="o">=</span> <span class="n">_PSF</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_PSF</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dark signal.</span>
<span class="sd">        [y0] = DN&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y0</span>

    <span class="nd">@y0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y0</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">_y0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imax</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y0</span> <span class="o">!=</span> <span class="n">_y0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y0</span> <span class="o">=</span> <span class="n">_y0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_y0</span><span class="w"> </span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ui</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intensity noise.&quot;&quot;&quot;</span>
        <span class="n">quant</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dark</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span>
        <span class="n">ui</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dark</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">quant</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">shot</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ui</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">upi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Phase uncertainty.</span>
<span class="sd">        [upi] = rad&quot;&quot;&quot;</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">MTF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span>
        <span class="n">SNR</span> <span class="o">=</span> <span class="n">B</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ui</span>
        <span class="n">upi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span> <span class="o">/</span> <span class="n">SNR</span>  <span class="c1"># local phase uncertainties</span>
        <span class="k">return</span> <span class="n">upi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uncertainty of measurement (standard deviation).</span>
<span class="sd">        [u] = px.</span>

<span class="sd">        It is based on the phase noise model from [Surrel 1997]</span>
<span class="sd">        and propagated through the unwrapping process and the phase fusion.&quot;&quot;&quot;</span>

        <span class="n">upin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># normalized local phase uncertainty</span>
        <span class="n">uxi</span> <span class="o">=</span> <span class="n">upin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span>  <span class="c1"># local positional uncertainties</span>
        <span class="n">ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">uxi</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># global positional uncertainty (by inverse variance weighting)</span>
        <span class="c1"># todo: factor out L ?!</span>
        <span class="k">return</span> <span class="n">ux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SNR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Signal-to-noise ratio of the phase shift coding.</span>

<span class="sd">        It is a masure of how many points can be distinguished within the screen length [0, R)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SNRdB</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Signal-to-noise ratio.</span>
<span class="sd">        [SNRdB] = dB.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SNR</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">DR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dynamic range of the phase shift coding.</span>

<span class="sd">        It is a measure of how many points can be distinguished within the unambiguousmeasurement range [0, UMR).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">UMR</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">DRdB</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dynamic range. [DRdB] = dB.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DR</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base parameters required for en- &amp; decoding fringe patterns.</span>

<span class="sd">        This contains all property objects of the class which have a setter method,</span>
<span class="sd">        i.e. are (usually) not derived from others.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>  <span class="c1"># sorted() ensures setting params in the right order in the setter method</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="s2">&quot;params&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">property</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">params</span>

    <span class="nd">@params</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">k</span><span class="p">,</span>
            <span class="n">v</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">):</span>  <span class="c1"># iterating self.params ensures that only properies with a setter method are set</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="s2">&quot;Nlvf&quot;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39; got overwritten by interdependencies. Choose consistent parameter set.&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39; got overwritten by interdependencies. Choose consistent parameter set.&quot;</span>
                        <span class="p">)</span>

    <span class="c1"># get default values from __init__</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">,</span> <span class="fm">__init__</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="c1"># restrict instance attributes to the ones listed here</span>
    <span class="c1"># commend the next line out or add &quot;__dict__&quot; to circumvent this</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;HMTlAB&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
        <span class="s2">&quot;logger&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_UMR&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_t&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># glossary</span>
    <span class="n">glossary</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">__k</span><span class="p">,</span> <span class="n">__v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">vars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">__v</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span> <span class="ow">and</span> <span class="n">__v</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">glossary</span><span class="p">[</span><span class="n">__k</span><span class="p">]</span> <span class="o">=</span> <span class="n">__v</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="c1"># # class docstring</span>
    <span class="c1"># __doc__ += &quot;\n\nParameters:\n&quot;</span>
    <span class="c1"># for __k, __v in sorted(vars().items()):</span>
    <span class="c1">#     if not __k.startswith(&quot;_&quot;):</span>
    <span class="c1">#         if isinstance(__v, property) and __v.__doc__ is not None:</span>
    <span class="c1">#             __doc__ += f&quot;    {__k}: {__v.__doc__}\n&quot;</span>

    <span class="c1"># docstring for __init__</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Parameter:</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">for</span> <span class="n">__k</span><span class="p">,</span> <span class="n">__v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">vars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">__k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">__v</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span> <span class="ow">and</span> <span class="n">__v</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">__k</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">[</span><span class="n">__k</span><span class="p">]</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">__v</span><span class="o">.</span><span class="vm">__doc__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">del</span> <span class="n">__k</span><span class="p">,</span> <span class="n">__v</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Christian Kludt.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>